<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MYSQL数据库</title>
    <link href="undefined2019/10/30/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/10/30/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="MySQL数据库增删改查SQL语句"><a href="#MySQL数据库增删改查SQL语句" class="headerlink" title="MySQL数据库增删改查SQL语句"></a>MySQL数据库增删改查SQL语句</h3><h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><pre><code class="mysql">show databases; </code></pre><h5 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h5><pre><code class="mysql">use 数据库名;</code></pre><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><pre><code class="mysql">CREATE DATABASE 数据库名;</code></pre><h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><pre><code class="mysql">DROP DATABASE 数据库名;</code></pre><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><pre><code class="mysql">create table 表名(    列名1 类型(长度) [约束],    列名2 类型(长度) [约束],    ……);</code></pre><h5 id="长度区别"><a href="#长度区别" class="headerlink" title="长度区别"></a>长度区别</h5><p>int类型带长度：不影响存取值，即使设定的值超出了长度的范畴，也能存，如果没有达到设定的长度，则使用空格自动填充到设定的长度<br>char类型：不可变字符，设定的长度就是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，使用空格填充到设定的长度<br>varchar：可变字符，设定的长度同样是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，不会使用空格填充，实际多长就是多长</p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><pre><code class="mysql">DROP TABLE 表名;</code></pre><h5 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h5><p>1.非空约束    NOT NULL</p><p>2.默认值约束  DEFAULT ‘男’</p><p>3.唯一约束    UNIQUE4.主键约束    PRIMARY KEY</p><h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h5><p>DESC 表名</p><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><h5 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h5><pre><code class="mysql">Alter table 表名  change  列名  新列名 类型;</code></pre><h5 id="修改列类型"><a href="#修改列类型" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  change 列名  列名  新类型;</code></pre><h5 id="修改列类型-1"><a href="#修改列类型-1" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  modify  列名  新类型;</code></pre><h5 id="数据查询-单表"><a href="#数据查询-单表" class="headerlink" title="==============================数据查询-单表================================="></a>==============================数据查询-单表=================================</h5><h5 id="查询表中全部信息"><a href="#查询表中全部信息" class="headerlink" title="查询表中全部信息"></a>查询表中全部信息</h5><pre><code class="mysql">select * from 表名;</code></pre><h5 id="查询表中指定列的信息"><a href="#查询表中指定列的信息" class="headerlink" title="查询表中指定列的信息"></a>查询表中指定列的信息</h5><pre><code class="mysql">select 列1,列2 from 表名;</code></pre><p>语句的执行顺序：from—&gt;select</p><h5 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h5><pre><code class="mysql">select distinct 列…. From 表名;</code></pre><h5 id="拼接结果"><a href="#拼接结果" class="headerlink" title="拼接结果"></a>拼接结果</h5><pre><code class="mysql">select concat(列1,列2) from 表名;</code></pre><h5 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h5><p>1.乘法和除法的优先级高于加法和减法<br>2.同级运算的顺序是从左到右<br>3.表达式中使用”括号”可强行改变优先级的运算顺序</p><pre><code class="mysql">select 列1[+-*/]列2 from 表名;</code></pre><h5 id="设置别名-注意：关键字as可以省略"><a href="#设置别名-注意：关键字as可以省略" class="headerlink" title="设置别名(注意：关键字as可以省略)"></a>设置别名(注意：关键字as可以省略)</h5><pre><code class="mysql">select 列 as 别名 from 表名;  select 列 别名 from 表名;     </code></pre><p> 语句的执行顺序：from—&gt;select</p><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><pre><code class="mysql">select 列… from 表名 where 条件;  </code></pre><h5 id="条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt"><a href="#条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt" class="headerlink" title="条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )"></a>条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )</h5><pre><code class="mysql">where 列  比较运算符  值;</code></pre><p>注意:字符串、日期需使用单引号括起来<br>语句的执行顺序：from—&gt;where—&gt;select</p><h5 id="逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或"><a href="#逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或" class="headerlink" title="逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )"></a>逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )</h5><pre><code class="mysql">where 条件1  逻辑运算符  条件2;  where not 条件; </code></pre><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><pre><code class="mysql">where 列 between 条件1  and 条件2;        </code></pre><p>//列在这个区间的值where 列 not between 条件1 and 条件2;    </p><p>//不在这个区间where !( 列 between 条件1 and 条件2 );    </p><p>//同样表示不在这个区间</p><h5 id="集合查询-判断列的值是否在指定的集合中"><a href="#集合查询-判断列的值是否在指定的集合中" class="headerlink" title="集合查询( 判断列的值是否在指定的集合中 )"></a>集合查询( 判断列的值是否在指定的集合中 )</h5><pre><code class="mysql">where 列 in(值1,值2);      </code></pre><p>//列中的数据是in后的值里面的where 列 not in(值1,值2);   </p><p>//不是in中指定值的数据</p><h5 id="NULL值查询-注意：列中值为null不能使用-去查询"><a href="#NULL值查询-注意：列中值为null不能使用-去查询" class="headerlink" title="NULL值查询( 注意：列中值为null不能使用=去查询 )"></a>NULL值查询( 注意：列中值为null不能使用=去查询 )</h5><pre><code class="mysql">where 列 is null;  </code></pre><p>//查询列中值为null的数据</p><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><h5 id="：表示0到多个字符，示例："><a href="#：表示0到多个字符，示例：" class="headerlink" title="%：表示0到多个字符，示例："></a>%：表示0到多个字符，示例：</h5><pre><code class="mysql">where 列 like &#39;%0&#39;;  </code></pre><p> //表示以0结尾where 列 like  ‘0%’;   </p><p>//表示以0开头where 列 like  ‘%0%’;  </p><p> //表示数据中包含0</p><h5 id="：表示一个字符，可多次使用，示例："><a href="#：表示一个字符，可多次使用，示例：" class="headerlink" title="_：表示一个字符，可多次使用，示例："></a>_：表示一个字符，可多次使用，示例：</h5><pre><code class="mysql">where 列 like &#39;%0_&#39;;   </code></pre><p>//数据结尾第二位是0</p><h5 id="结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序"><a href="#结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序" class="headerlink" title="结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)"></a>结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)</h5><pre><code class="mysql">where 条件 order by 列 [asc/desc]</code></pre><p>语句的执行顺序：from—&gt;where—&gt;select—&gt;order by</p><h5 id="分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数"><a href="#分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数" class="headerlink" title="分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )"></a>分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )</h5><pre><code class="mysql">where [条件] limit beginIndex,pageSize;</code></pre><p>ex：每页显示3条数据<br>第一页: SELECT * FROM 表名 LIMIT 0,3    –0,1,2<br>第二页: SELECT * FROM 表名 LIMIT 3,3    –3,4,5<br>第三页: SELECT * FROM 表名 LIMIT 6,3    –6,7,8<br>第四页: SELECT * FROM 表名 LIMIT 9,3    –9,10,11<br>  ……<br>第七页: SELECT * FROM 表名 LIMIT 18,3   –18,19,20</p><h5 id="beginIndex公式：-当前页数-1-pageSize"><a href="#beginIndex公式：-当前页数-1-pageSize" class="headerlink" title="beginIndex公式：(当前页数-1)*pageSize"></a>beginIndex公式：(当前页数-1)*pageSize</h5><h5 id="聚集函数-作用于一组数据，并对一组数据返回一个值"><a href="#聚集函数-作用于一组数据，并对一组数据返回一个值" class="headerlink" title="聚集函数( 作用于一组数据，并对一组数据返回一个值 )"></a>聚集函数( 作用于一组数据，并对一组数据返回一个值 )</h5><h5 id="COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"><a href="#COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值" class="headerlink" title="COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"></a>COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值</h5><h5 id="MAX-统计计算最大值"><a href="#MAX-统计计算最大值" class="headerlink" title="MAX:  统计计算最大值"></a>MAX:  统计计算最大值</h5><h5 id="MIN-统计计算最小值"><a href="#MIN-统计计算最小值" class="headerlink" title="MIN:  统计计算最小值"></a>MIN:  统计计算最小值</h5><h5 id="SUM-统计计算求和"><a href="#SUM-统计计算求和" class="headerlink" title="SUM:  统计计算求和"></a>SUM:  统计计算求和</h5><h5 id="AVG-统计计算平均值"><a href="#AVG-统计计算平均值" class="headerlink" title="AVG:  统计计算平均值"></a>AVG:  统计计算平均值</h5><h5 id="分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后"><a href="#分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后" class="headerlink" title="分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )"></a>分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )</h5><pre><code class="mysql">select 聚集函数 from 表名 where [条件] group by 列 having 分组后的条件</code></pre><p>语句的执行顺序：FROM—&gt; WHERE—&gt;group by—-&gt;Having—&gt;SELECT–&gt;ORDER BY</p><h5 id="Where和having的区别："><a href="#Where和having的区别：" class="headerlink" title="Where和having的区别："></a>Where和having的区别：</h5><h5 id="Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算"><a href="#Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算" class="headerlink" title="Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算"></a>Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算</h5><h5 id="Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤"><a href="#Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤" class="headerlink" title="Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)"></a>Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)</h5><p>注意：使用having的时候，它是可以使用别名的</p><h5 id="数据查询-多表"><a href="#数据查询-多表" class="headerlink" title="===============================数据查询-多表==============================="></a>===============================数据查询-多表===============================</h5><h5 id="交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积"><a href="#交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积" class="headerlink" title="交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积"></a>交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积</h5><p>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p><pre><code class="mysql">select *  from 表1,表2</code></pre><h5 id="内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据"><a href="#内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据" class="headerlink" title="内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据"></a>内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据</h5><pre><code class="mysql">select * from 表1,表2  where 表1.字段=表2.字段;  </code></pre><p>//隐式内连接,使用where条件消除笛卡尔积</p><pre><code class="mysql">select * from 表1 [inner] join 表2 on 表1.字段=表2.字段;</code></pre><p> //显式内连接,如果是多张表，则一直在join..on后依次添加join..on即可,inner关键字可被省略</p><h5 id="外连接：左外连接、右外连接、全外连接"><a href="#外连接：左外连接、右外连接、全外连接" class="headerlink" title="外连接：左外连接、右外连接、全外连接"></a>外连接：左外连接、右外连接、全外连接</h5><h5 id="左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"><a href="#左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解" class="headerlink" title="左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"></a>左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段;   </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"><a href="#右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解" class="headerlink" title="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"></a>右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段;  </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"><a href="#全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名" class="headerlink" title="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"></a>全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名</h5><p>多用在分类数据、省市县分类数据、权限…</p><pre><code class="mysql">select 表1.字段1,表2.字段2 from 表名 as 表1,表名 as 表2 where 表1.字段1=表2.字段2 </code></pre><h5 id="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"><a href="#子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套" class="headerlink" title="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"></a>子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套</h5><pre><code class="mysql">select * from (select * from 表名) as 别名select * from where 条件</code></pre><p>//条件中包含查询语句</p><p>注意：1.查询结果的虚拟表必须取别名<br>           2.字段与关键字一样，冲突时，需要给字段名加``,(Esc键下面、1的左边)<br>           3.如果给虚拟结果表中的字段取了别名，则对虚拟结果表查询时，应该用 表别名.虚拟表字段别名</p><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="===============================插入数据==============================="></a>===============================插入数据===============================</h5><pre><code class="mysql">insert into 表名(字段1,字段2..) values(值1,值2…);   </code></pre><p>注意： 1.如果插入的表中的主键是自增类型的，可以不用插入值<br>            2.如果主键是非自增 ，插入的数据则是填补主键字段值空余的值<br>            3.如果主键设置了自动递增，会从主键字段最大值开始插入数据</p><h5 id="其他插入方式："><a href="#其他插入方式：" class="headerlink" title="其他插入方式："></a>其他插入方式：</h5><pre><code class="mysql">insert into 表名(字段1,字段2) values(值1,值2),(值1,值2);    </code></pre><p>//插入多条数据【MYSQL】insert into 表名 values(值1,值2);                    </p><p>//针对全表所有字段进行插入操作insert into 表名(字段) select 字段 from 表2;         </p><p>//查询结果插入insert into 表名 select 字段 from 表2;               </p><p>//查询结果，全表插入</p><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="===============================修改数据==============================="></a>===============================修改数据===============================</h5><pre><code class="mysql">update 表 set 字段=值 where 条件; </code></pre><p> //带条件修改指定数据，否则修改全表</p><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="===============================删除数据==============================="></a>===============================删除数据===============================</h5><pre><code class="mysql">delete from 表 where 条件; </code></pre><p>//删除数据带条件指定数据，否则删除全表数据</p><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="===============================数据备份==============================="></a>===============================数据备份===============================</h5><h5 id="在命令行窗口进行，若操作系统版本高，则使用管理员模式"><a href="#在命令行窗口进行，若操作系统版本高，则使用管理员模式" class="headerlink" title="在命令行窗口进行，若操作系统版本高，则使用管理员模式"></a>在命令行窗口进行，若操作系统版本高，则使用管理员模式</h5><p>导出：</p><p>mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地</p><p>ex:         mysqldump -uroot -proot jdbcdemo&gt; C:/shop_bak.sql<br>导入：</p><p>mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址</p><p>ex:         mysql -uroot -proot jdbcdemo&lt; C:/shop_bak.sql<br>使用可视化导入导出：<br>Navicat工具的导入和导出/Navicat工具的备份和还原</p><h5 id="数据索引"><a href="#数据索引" class="headerlink" title="===============================数据索引==============================="></a>===============================数据索引===============================</h5><h5 id="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"><a href="#索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。" class="headerlink" title="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"></a>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</h5><h5 id="什么列适合建索引？？"><a href="#什么列适合建索引？？" class="headerlink" title="什么列适合建索引？？"></a>什么列适合建索引？？</h5><p>1.表的主键、外键必须有索引；<br>2.数据量超过30000的表应该有索引；<br>3.经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4.经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5.索引应该建在选择性高的字段上；<br>6.索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </p><h5 id="sql语句创建和删除索引："><a href="#sql语句创建和删除索引：" class="headerlink" title="sql语句创建和删除索引："></a>sql语句创建和删除索引：</h5><p>创建索引: </p><p>CREATE INDEX 索引名称 ON 表名 (列名)</p><p>删除索引:<br>方式一：</p><p>DROP INDEX 索引名 ON 表名 </p><p>方式二:  </p><p>ALTER TABLE 表名 DROP INDEX 索引名</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Request案例</title>
    <link href="undefined2019/10/30/Request%E6%A1%88%E4%BE%8B/"/>
    <url>2019/10/30/Request%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Request案例代码："><a href="#Request案例代码：" class="headerlink" title="Request案例代码："></a>Request案例代码：</h3><p>（1）index.jsp</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;NewFile.jsp&quot; meshod=&quot;post&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;        多选：&lt;br&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;唱&quot;&gt;唱        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;跳&quot;&gt;跳        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;rap&quot;&gt;rap        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;篮球&quot;&gt;篮球        &lt;br&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;input type=&quot;reset&quot; name=&quot;reset&quot; value=&quot;取消&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）NewFile.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;% request.setCharacterEncoding(&quot;UTF-8&quot;);String name=request.getParameter(&quot;user&quot;);String pwd=request.getParameter(&quot;password&quot;);String [] y=request.getParameterValues(&quot;dx&quot;);%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    用户名是：&lt;%=name %&gt;&lt;br&gt;    密码是：&lt;%=pwd %&gt;&lt;br&gt;    信息来源是：&lt;% for(int i=0;i&lt;y.length;i++){        out.println(y[i]);    } %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点总结</title>
    <link href="undefined2019/10/11/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/11/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章面向对象"><a href="#第二章面向对象" class="headerlink" title="第二章面向对象"></a>第二章面向对象</h2><p>1.面向对象：面向对象思想就是把一个项目，一件事情分成更小的项目，每一部分负责什么功能，最后再有这些部分组合成一个整体。</p><p>2.类的创建</p><pre><code class="java">    语法：public class 类名{}​      File---&gt;new---&gt;class---&gt;类名</code></pre><p>​      </p><p>3.创建对象</p><pre><code>类名 对象名=new 类名();​      对象名.方法名(); 对象名.属性</code></pre><p>4.构造方法：方法名和类名相同,没有返回值</p><pre><code>     public class 类名{​         public 类名(){}//主要的做用是初始化操作​      }</code></pre><p>5.构造方法重载</p><p>（1）构造方法的重载：方法名与类名相同，参数列表不同</p><p>（2）方法的重载：在同一个类中包含了两个或者两个以上的方法，它们的方法名相同，方法的参数个数，顺序，类型不同，则称这个方法被重载了，这个过程称为方法的重载。</p><p>（3）构造方法的作用：用来实现多种初始化行为。</p><pre><code>    public class 类名{​         public 类名(){}​         public 类名(String name,int age){}​      }</code></pre><p>6.构造方法的执行</p><pre><code>     new 类名();---&gt;执行构造方法​      super();---&gt;执行了父类的构造方法</code></pre><p>7.static静态修饰符</p><p>   （1）含义：static可以用来修饰属性，方法，和代码块。static修饰的变量属于这个类所有，即由这个类创建的所有对象共用一个static变量。通常把static修饰的属性和方法称为类属性（也可以称为类变量），类方法。不使用static修饰的属性和方法属于单个对象，通常称为实例属性，实例方法。</p><p>（2）要点：</p><p>​    1.在加载类的过程中，完成静态变量的内存分配，再执行静态代码块，两者是在创建对象之前执行的。</p><p>​    2.类属性和类方法可以通过类名和对象名访问，实例属性和实例方法只能通过对象名访问。</p><p>​    3.类方法只能访问类属性和其他类方法，</p><p>注意：静态方法中不能使用this和super关键字。</p><p>8.java内存（栈和堆，static，方法区，gc（垃圾回收机制））</p><p>9.八种基本数据类型：</p><pre><code>    byte  short   int   long    float   double   Boolean   char</code></pre><h2 id="第三章面向对象三大特征—封装"><a href="#第三章面向对象三大特征—封装" class="headerlink" title="第三章面向对象三大特征—封装"></a>第三章面向对象三大特征—封装</h2><h3 id="第三章-面向对象三大特征—封装"><a href="#第三章-面向对象三大特征—封装" class="headerlink" title="第三章 面向对象三大特征—封装"></a>第三章 面向对象三大特征—封装</h3><p>1.封装的概念：封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部的信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>2.封装的步骤</p><p>​      1.把属性私有化（private）</p><p>​      2.对这些属性设置get和set方法</p><p>​      3.调用处理这些方法</p><p>3.封装的作用与好处：</p><p>作用：避免一些用一些不合乎常理的操作</p><p>好处：</p><p>（1） 提高了安全性</p><p>（2） 提高了复用性</p><p>（3） 隐藏了实现细节</p><p>4.封装的案例:</p><pre><code class="java">/* 文件名: EncapTest.java */public class EncapTest{   private String name;   private String idNum;   private int age;   public int getAge(){​      return age;   }   public String getName(){​      return name;   }   public String getIdNum(){​      return idNum;   }   public void setAge( int newAge){​      age = newAge;   }   public void setName(String newName){​      name = newName;   }   public void setIdNum( String newId){​      idNum = newId;   }}/* F文件名 : RunEncap.java */public class RunEncap{   public static void main(String args[]){​      EncapTest encap = new EncapTest();​      encap.setName(&quot;James&quot;);​      encap.setAge(20);​      encap.setIdNum(&quot;12343ms&quot;);​      System.out.print(&quot;Name : &quot; + encap.getName()+ ​                             &quot; Age : &quot;+ encap.getAge());​    }}</code></pre><p>5.修饰符</p><p>​      public—&gt;公共的：在一个项目中都可以访问，权限最高</p><p>​      private—&gt;私有的：只能在本类中进行访问，权限最低</p><p>​      protected—&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类</p><p>​      default—&gt;默认的：同一个包能访问</p><h2 id="第四章-面向对象三大特征—继承"><a href="#第四章-面向对象三大特征—继承" class="headerlink" title="第四章 面向对象三大特征—继承"></a>第四章 面向对象三大特征—继承</h2><p>1.继承的概念：父亲儿子</p><p>2.继承的关键字：extends</p><p>3.继承的好处：</p><p>   （1）提高了代码的重用性</p><p>   （2）提高了代码的可扩展性</p><p>3.继承的语法：</p><pre><code>     public class 类名  extends 父类{    代码块   }</code></pre><p>4.继承的使用与说明：</p><p>   （1）使用：</p><p>可以直接调用父类的非私有属性和方法</p><p>​         可以用super.方法     super.属性</p><p>   （2）说明： Java中的继承只能单继承，</p><p>5.父类构造方法调用：super();</p><p>​     //super指代的是父类对象，this指代的是本类对象</p><p>​      调用父类的构造方法必须在之类中调用</p><p>​      必须实在之类构造方法的第一行代码</p><p>6.继承中的构造方法要点：</p><p>   （1）执行子类的构造方法，会默认执行父类的无参构造方法</p><p>  （2）当子类没有无参构造方法，但是有有参构造方法,子类的构造方法需手动添加</p><p>  （3）父类没有定义无参构造方法，定义了带参构造方法，子类的构造方法必须调用父类的带参构造方法。</p><p>  （4）无论是super还是this调用构造方法，只能放在第一行，构造方法只能调用一个</p><p>  （5）构造方法只能在构造方法中调用</p><p>7.重写@Override</p><p>​      必须继承</p><p>​      方法名一致，参数个数，顺序，类型全部一致</p><p>8.重载与重写的区别：</p><p>重载:一定发生在同一类中，方法名相同，参数不同（类型不同，数量不同）</p><p>重写：一定发生在父类和子类中，方法名相同，参数相同，方法体不同</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="第五章-面向对象—多态"><a href="#第五章-面向对象—多态" class="headerlink" title="第五章 面向对象—多态"></a>第五章 面向对象—多态</h2><p>1.多态的概念：不同对象对同一消息产生不同的响应。</p><p>2.多态的必要条件</p><p>   （1）继承</p><p>   （2）重写</p><p>   （3）父类引用指向子类对象（向上转型）</p><p>3.多态的优点：</p><p>   （1）消除类型之间的耦合关系</p><p>   （2）可替换性</p><p>   （3）可扩展性</p><p>   （4）接口性</p><p>   （5）灵活性</p><p>   （6）简化性</p><p>3.多态的使用</p><p>   （1）第一个例子</p><pre><code class="java"> public class Father{​         public void cooking(){​            System.out.println(&quot;米饭&quot;);​         }​      }​      public class Son extends Father{​         @Override​         public void cooking(){​            System.out.println(&quot;熬粥&quot;);​         }​      }​      public class Test {​         public static void main(String[] args) {​            Father son=new Son();​            son.cooking();​         }​      }</code></pre><p>   （2）第二个例子</p><pre><code class="java"> public class Test {​    public static void main(String[] args) {​      show(new Cat());  // 以 Cat 对象调用 show 方法​      show(new Dog());  // 以 Dog 对象调用 show 方法​                ​      Animal a = new Cat();  // 向上转型  ​      a.eat();               // 调用的是 Cat 的 eat​      Cat c = (Cat)a;        // 向下转型  ​      c.work();        // 调用的是 Cat 的 work  }  ​            ​    public static void show(Animal a)  {​      a.eat();  ​        // 类型判断​        if (a instanceof Cat)  {  // 猫做的事情 ​            Cat c = (Cat)a;  ​            c.work();  ​        } else if (a instanceof Dog) { // 狗做的事情 ​            Dog c = (Dog)a;  ​            c.work();  ​        }  ​    }  }abstract class Animal {  ​    abstract void eat();  }  class Cat extends Animal {  ​    public void eat() {  ​        System.out.println(&quot;吃鱼&quot;);  ​    }  ​    public void work() {  ​        System.out.println(&quot;抓老鼠&quot;);  ​    }  }  class Dog extends Animal {  ​    public void eat() {  ​        System.out.println(&quot;吃骨头&quot;);  ​    }  ​    public void work() {  ​        System.out.println(&quot;看家&quot;);  ​    }  }</code></pre><p> 4.向上转型（子类向父类的转换）  </p><pre><code> 语法 ：​      &lt;父类型&gt;  &lt;引用变量名&gt; = new  &lt;子类型&gt;（）；​      例如：Animal an1=new Dog（）；</code></pre><p>5.向下转型（必须基于向上转型）</p><pre><code>    例如：Son son=(Son)father;</code></pre><p>6.注意：</p><p>   （1）属性无多态这个属性，只看“=”左边的类型</p><p>   （2）编译时，能“.”出来，能调用的看“=”左边</p><p>7.Instanceof运算符：</p><p>8.异常的处理（Try-catch-finally块）：</p><pre><code>语法：​      Try{​         代码块；}catch（Exception  e）{   代码块；}finally{   代码块；}</code></pre><p>注意：</p><p>（1） catch（Exception  e）一定放在所有catch块的最后</p><p>（2） finally{}块里面的代码一定会执行</p><p>结束的语句：</p><pre><code>   （1）return；   （2）system.exit（0）;</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h2 id="第六章-抽象"><a href="#第六章-抽象" class="headerlink" title="第六章 抽象"></a>第六章 抽象</h2><p>1.抽象的概念:当一个类没有足够的信息去描述一个具体的对象，那么我们称之为抽象类。</p><p>2.抽象的关键字</p><p>​      abstract</p><p>​      可以修饰类，可以修饰方法</p><p>3.抽象类的作用：</p><p>   （1）抽象类是用来继承的</p><p>   （2）抽象类无法new出对象</p><p>4.抽象的用法</p><pre><code>     //抽象类​      public abstract class 类名{​         //抽象方法没有方法体​         public abstract void 方法名();   ​      }     //当父类是抽象类的时候，子类必须重写父类里面的抽象方法</code></pre><p>​     </p><p>5.final修饰符：最终的</p><p>   修饰变量，修饰方法，修饰类</p><p>   （1）.当修饰变量时，变量转换成常量，常量的值不能改变</p><p>​      final int a=18;//a=18;不能改变,必须给一个初始值</p><p>   （2）.当修饰方法时，该方法不能被重写</p><p>   （3）.当修饰类时，该类不能被继承</p><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><p>为什么要用接口？：因为JAVA只支持单继承。</p><ol><li>接口的概念</li></ol><p>2.接口的关键字</p><p>​      interface</p><p>3.接口的语法</p><pre><code>      public interface 接口名{}​      File---&gt;new---&gt;interface//创建接口</code></pre><p>4.接口的用法</p><pre><code>      实现接口的关键字  implements​      public interface 接口名{​         //接口是纯抽象类​         //接口里面的方法都是抽象方法​         void setData();​      }​      public class Play implements 接口名{​         @Override​         void setData(){​         }​      }​      public class Test {​         public static void main(String[] args) {​            Play play=new Play();​            play.setData();​         }​      }​      注意接口可以进行多继承​      public interface 接口名 extends 接口名，接口名{}​      一般用法​      public class 类名 extends 父类 implements 接口，接口{}</code></pre><p>多态与接口的区别：</p><p>（1） 多态：难</p><p>（2） 接口：简单，不能随意定义属性和方法，只能定义抽象方法，并且实现对口必须重写。</p><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h2 id="第八章-集合框架"><a href="#第八章-集合框架" class="headerlink" title="第八章 集合框架"></a>第八章 集合框架</h2><p>1.ArrayList</p><p>  1.用法</p><pre><code>     ArrayList list=new ArrayList();    list.add();//添加数据    list.get();//获取数据</code></pre><p>2.Map的用法：</p><pre><code>       Map map=new HasMap();​      map.put(key,value);//key不能重复​      map.get(key);//获取key对象的value</code></pre><p>3.泛型</p><pre><code>      ArrayList&lt;String&gt; list=new ArrayList&gt;&lt;String&gt;();      Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();      ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="undefined2019/10/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/10/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h3><pre><code class="java">System.out.println(&quot;小可爱，你好呀&quot;);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>