<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JSP中内置对象二</title>
    <link href="undefined2019/11/12/JSP%E4%B8%AD%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E4%BA%8C/"/>
    <url>2019/11/12/JSP%E4%B8%AD%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><p>在JSP中一共预先定义了9个这样的对象，分别为request、response、session、application、out、pageContext、config、page和exception。</p><p><img src="E:%5Chexo%5Cblog%5Csource%5Cimg%5C2.png" srcset="/img/loading.gif" alt></p><h3 id="1-request对象（request对象用于处理HTTP请求中的各项参数）"><a href="#1-request对象（request对象用于处理HTTP请求中的各项参数）" class="headerlink" title="1.request对象（request对象用于处理HTTP请求中的各项参数）"></a>1.request对象（request对象用于处理HTTP请求中的各项参数）</h3><p>request对象封装了由客户端生成的HTTP请求的所有细节，主要包括HTTP头信息、系统信息、请求方式和请求参数等。通过request对象提供的相应方法可以处理客户端浏览器提交的HTTP请求中的各项参数。</p><p>request对象的常用方法：</p><p><img src="E:%5Chexo%5Cblog%5Csource%5Cimg%5C3.png" srcset="/img/loading.gif" alt></p><h3 id="2、response对象"><a href="#2、response对象" class="headerlink" title="2、response对象"></a>2、response对象</h3><p>response对象用于响应客户请求，向客户端输出信息。它封装了JSP产生的响应，并发送到客户端以响应客户端的请求。请求的数据可以是各种数据类型，甚至是文件。response对象在JSP页面内有效。</p><p>request对象的常用方法：</p><pre><code>方法                                           说明sendRedirect(String path)                    将网页重定向到另一个页面。setHeader(String name, String value)        设置HTTP响应报头信息。</code></pre><h3 id="3、session对象"><a href="#3、session对象" class="headerlink" title="3、session对象"></a>3、session对象</h3><p>session在网络中被称为会话。由于HTTP协议是一种无状态协议，也就是当一个客户向服务器发出请求，服务器接收请求，并返回响应后，该连接就结束了，而服务器并不保存相关的信息。为了弥补这一缺点，HTTP协议提供了session。通过session可以在应用程序的Web页面间进行跳转时，保存用户的状态，使整个用户会话一直存在下去，直到关闭浏览器。但是，如果在一个会话中，客户端长时间不向服务器发出请求，session对象就会自动消失。这个时间取决于服务器，例如，Tomcat服务器默认为30分钟。不过这个时间可以通过编写程序进行修改。</p><p>session对象的常用方法：</p><p><img src="E:%5Chexo%5Cblog%5Csource%5Cimg%5C4.png" srcset="/img/loading.gif" alt></p><p><strong>示例：</strong>保存与获取session对象信息。</p><pre><code>&lt;%    session.setAttribute(&quot;UserName&quot;, &quot;pan_junbiao的博客&quot;);           //保存session对象    String userName = session.getAttribute(&quot;UserName&quot;).toString();  //获取session对象%</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP中内置对象一</title>
    <link href="undefined2019/11/11/JSP%E4%B8%AD%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E4%B8%80/"/>
    <url>2019/11/11/JSP%E4%B8%AD%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><h3 id="一-内置对象"><a href="#一-内置对象" class="headerlink" title="一.内置对象"></a>一.内置对象</h3><h4 id="1-什么是内置对象"><a href="#1-什么是内置对象" class="headerlink" title="1.什么是内置对象"></a>1.什么是内置对象</h4><p>在jsp开发中会频繁使用到一些对象,如ServletContext HttpSession PageContext等.如果每次我们在jsp页面中需要使用这些对象都要自己亲自动手创建就会特别的繁琐.SUN公司因此在设计jsp时,在jsp页面加载完毕之后自动帮开发者创建好了这些对象,开发者只需要使用相应的对象调用相应的方法即可.这些系统创建好的对象就叫做内置对象。</p><h4 id="2-内置对象（又叫隐含对象-优点"><a href="#2-内置对象（又叫隐含对象-优点" class="headerlink" title="2.内置对象（又叫隐含对象)优点"></a>2.内置对象（又叫隐含对象)优点</h4><pre><code>1. 由JSP规范提供,不用编写者实例化。 2. 通过Web容器实现和管理 3. 所有JSP页面均可使用 4. 只有在脚本元素的表达式或代码段中才可使用(&lt;%=使用内置对象%&gt;或&lt;%使用内置对象%&gt;)</code></pre><h4 id="3-JSP内置对象包括"><a href="#3-JSP内置对象包括" class="headerlink" title="3.JSP内置对象包括"></a>3.JSP内置对象包括</h4><pre><code>（1）request            获取用户的请求信息，向客户端请求数据（2）response            服务器向客户端的回应信息封装了jsp产生的响应,然后被发送到客户端以响应客户的请求（3）out                向客户端输出数据（4）session            用来保存每个用户的信息,以便跟踪每个用户的操作状态（5）application        表示所有用户的共享信息，应用程序对象（6）config            服务器配置信息，可以取得初始化参数（7）pageContext        提供了对jsp页面所有对象以及命名空间的访问。（8）page                Jsp实现类的实例,它是jsp本身,类似于Java类中的this关键字（9）Exception        反映运行的异常</code></pre><h4 id="4-JSP九大内置对象分为四类："><a href="#4-JSP九大内置对象分为四类：" class="headerlink" title="4.JSP九大内置对象分为四类："></a>4.JSP九大内置对象分为四类：</h4><pre><code>输入输出对象：out对象、response对象、request对象通信控制对象：pageContext对象、session对象、application对象Servlet对象:page对象、config对象错误处理对象：exception对象</code></pre><h4 id="5-注意："><a href="#5-注意：" class="headerlink" title="5.注意："></a>5.注意：</h4><pre><code>在这9个对象中有很多是极少会被使用的，例如：config、page、exception基本不会使用。在这9个对象中有两个对象不是每个JSP页面都可以使用的：exception、session。在这9个对象中有很多前面已经学过的对象：out、request、response、application、session、config。</code></pre><h3 id="二-详细介绍"><a href="#二-详细介绍" class="headerlink" title="二.详细介绍"></a>二.详细介绍</h3><h4 id="1-request对象"><a href="#1-request对象" class="headerlink" title="1.request对象"></a>1.request对象</h4><hr><p>request 对象是 javax.servlet.httpServletRequest类型的对象（客户端的请求信息被封装在request对象中）。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。</p><h5 id="（1）request对象常用方法"><a href="#（1）request对象常用方法" class="headerlink" title="（1）request对象常用方法"></a>（1）request对象常用方法</h5><pre><code>getParameter：根据页面表单组件名称获取页面提交数据getParameterValues ： 获取一组以相同名称命名的表单组件提交的数据。setCharacterEncoding ：用于解决乱码问题，可以设置请求的编码。getRequestDispatcher ：返回一个对象，该对象的forward方法用于转发请求。</code></pre><h5 id="（2）request对象其他方法（不太常用）"><a href="#（2）request对象其他方法（不太常用）" class="headerlink" title="（2）request对象其他方法（不太常用）"></a>（2）request对象其他方法（不太常用）</h5><pre><code>（1）String getParameter(String name) 返回name指定参数的参数值；（2）String[ ] getParameterValues(String name) 返回包含参数name的所有值的数组；（3）void setAttribute(String,Object);存储此请求中的属性；（4）object getAttribute(String name);返回指定属性的属性值；（5）String getContentType(); 得到请求体的MIME类型；（6）String getProtocol(); 返回请求用的协议类型及版本号；（7）String getServerName(); 返回接受请求的服务器主机名；（8）int getServerPort() 返回服务器接受此请求所用的端口号；（9）String getCharacterEncoding() 返回字符编码方式；（10）void setCharacterEncoding() 设置请求的字符编码方式；（11）int getContentLength() 返回请求体的长度（以字节数）（12）String getRemoteAddr() 返回发送此请求的客户端IP地址；（13）String getRealPath(String path) 返回一虚拟路径的真实路径；（14）String request.getContextPath() 返回上下文路径；</code></pre><h4 id="2-reponse对象"><a href="#2-reponse对象" class="headerlink" title="2.reponse对象"></a>2.reponse对象</h4><hr><p>response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。</p><h5 id="（1）response对象的常用方法："><a href="#（1）response对象的常用方法：" class="headerlink" title="（1）response对象的常用方法："></a>（1）response对象的常用方法：</h5><pre><code>addCookie ： 向客户端添加CookiesetContentTYpe ： 设置HTTP响应的contentTYpe类型setCharacterEncoding ： 设置响应采用的字符编码，用于乱码问题。。sendRedirect ： 将请求重定向到另一个URL上　　　　　　response对象最常用的方法是sendRedirect ()负责页面重定向。</code></pre><h5 id="（2）response对象的其他方法："><a href="#（2）response对象的其他方法：" class="headerlink" title="（2）response对象的其他方法："></a>（2）response对象的其他方法：</h5><pre><code>（1）String getCharacterEncoding() 返回响应用的是何种字符编码；（2）void setContentType（String type） 设置响应的MIME类型；（3）PrintWriter getWriter() 返回可以向客户端输出字符的一个对象；　　　注意比较：PrintWriter与内置out对象的区别；（4）sendRedirect(java.lang.String location) 重新定向客户端的请求；</code></pre><p>注意：</p><pre><code>（1）request的getRequestDispatcher负责转发，response的sendRedirect 负责重定向    他们两的区别：转发携带数据到另一个页面，重定向不携带数据。转发地址不变，重定向地址改变。（2）request对象是负责客户端向服务器端发送请求，而response是负责把服务器端的信息返回给客户端。</code></pre><h4 id="3-out"><a href="#3-out" class="headerlink" title="3.out"></a>3.out</h4><hr><p>out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。</p><p>常用方法</p><pre><code>（1）void println() 向客户端打印字符串；（2）void clear() 清除缓冲区的内容，如果在flush之后调用会抛出异常；（3）void clearBuffer() 清除缓冲区的内容，如果在flush之后调用不会抛出异常；（4）void flush() 将缓冲区内容输出到客户端；（5）int getBufferSize() 返回缓冲区字节数的大小，如不设缓冲区则为0；（6）int getRemaining() 返回缓冲区还剩余多少可用；（7）boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常；（8）void close() 关闭输出流；</code></pre><h4 id="4-session对象"><a href="#4-session对象" class="headerlink" title="4.session对象"></a>4.session对象</h4><hr><p>session对象：是一个jsp内置对象，它在第一个jsp被装载时自动创建，完成会话期管理。从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离  开这个服务器结束(或者超时)，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间切换，服务器应当通过某种办法知道这是一个客户，就需要创建session对象。</p><p>session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。</p><h5 id="（1）session对象的简介与作用："><a href="#（1）session对象的简介与作用：" class="headerlink" title="（1）session对象的简介与作用："></a>（1）session对象的简介与作用：</h5><pre><code>（1）session对象是一个JSP内置对象；（2）session对象在第一个JSP页面被装载时自动创建，完成会话期管理；（3）从一个客户打开浏览器并链接到服务器开始，到客户关闭浏览器离开这个服务器结束，被成为一个会话；（4）当一个客户访问一个服务器时，可能会在服务器的几个页面之间切换，服务器应当通过某种办法知道这是一个客户，就需要session对象；（5）session对象是HttpSession类的实例；</code></pre><h5 id="（2）session的常用方法："><a href="#（2）session的常用方法：" class="headerlink" title="（2）session的常用方法："></a>（2）session的常用方法：</h5><pre><code>getId ：获取sessionidsetMaxInactiveInterval ：设置session的非活动时间getMaxInactiveInterval ：获取session的有效非活动时间，以秒为单位。invalidate ：设置session对象失效setAttribute :：设置以key/value的方式存储对象getAttribut ： 以key的方式查看session会话中的对象removeAttribut ：以key的方式删除session会话中的对象</code></pre><h5 id="（3）session的其他方法"><a href="#（3）session的其他方法" class="headerlink" title="（3）session的其他方法"></a>（3）session的其他方法</h5><pre><code>（1）long getCreationTime();  返回SESSION创建时间；（2）public String getId();  返回SESSION创建时JSP引擎为它设的唯一ID号；（3）public Object setAttribute(String name,Object value);  使用指定名称将对象绑定到此会话；（4）public Object getAttribute(String name);  返回与此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回null；（5）String[ ] getValueName();  返回一个包含此SESSION中所有可用属性的数组；（6）int getMaxInactiveInterval();  返回两次请求间隔多长时间此SESSION被取消（单位秒）；</code></pre><h4 id="5-application对象"><a href="#5-application对象" class="headerlink" title="5.application对象"></a>5.application对象</h4><hr><p>application对象代表当前的应用程序（应用一旦启动便会自动生成一个application对象），存在于服务器的内存空间中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。</p><h5 id="（1）简介与作用："><a href="#（1）简介与作用：" class="headerlink" title="（1）简介与作用："></a>（1）简介与作用：</h5><pre><code>    a、application对象实现了用户间数据的共享，可存放全局变量；　　 b、application开始于服务器的启动，终止于服务器的关闭；　　 c、在用户的前后连接或不同用户之间的连接中，可以对application对象的同一属性进行操作；　　 d、在任何地方对application对象属性的操作，都将影响到其他用户对此的访问；　　 e、服务器的启动和关闭决定了application对象的生命；　　 f、application对象是ServletContext类的实例；</code></pre><h5 id="（2）常用方法"><a href="#（2）常用方法" class="headerlink" title="（2）常用方法"></a>（2）常用方法</h5><pre><code>（1）public void setAttribute(String name, Object value); 使用指定名称将对象绑定到此会话。（2）public Object getAttribute(String name); 返回与此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回null。（3）Enumeration getAttributeNames(); 返回所有可用属性名的枚举。（4）String getServerInfo(); 返回JSP（SERVLET）引擎名及版本号。int </code></pre><h5 id="（3）应用："><a href="#（3）应用：" class="headerlink" title="（3）应用："></a>（3）应用：</h5><p>​                    为多个用户共享全局信息。比如当前的在线人数等。</p><h4 id="6-config对象"><a href="#6-config对象" class="headerlink" title="6.config对象"></a>6.config对象</h4><hr><p>config 对象的主要作用是取得服务器的配置信息。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数</p><h5 id="（1）常用方法"><a href="#（1）常用方法" class="headerlink" title="（1）常用方法"></a>（1）常用方法</h5><pre><code>（1）ServletContext getServletContext() 返回含有服务器相关信息的ServletContext对象；　　（2）String getInitParameter(String name) 返回初始化参数的值；　　（3）Enumeration getInitParameterNames() 返回Servlet初始化所需所有参数的枚举；</code></pre><h5 id="（2）注意"><a href="#（2）注意" class="headerlink" title="（2）注意"></a>（2）注意</h5><pre><code>一般项目中，jsp被用作模版技术，也就是位于表示层，而位于表示层的jsp文件一般是不需要配置信息的所以此对象在jsp程序中其实很少使用</code></pre><h4 id="7-pageContest"><a href="#7-pageContest" class="headerlink" title="7.pageContest"></a>7.pageContest</h4><hr><p>pageContext 的对象类型是PageContext,叫jsp的上下文对象。</p><h5 id="（1）作用"><a href="#（1）作用" class="headerlink" title="（1）作用"></a>（1）作用</h5><pre><code>（1）pageContext对象提供了对JSP页面内所有的对象及名字空间的访问；（2）pageContext对象可以访问到本页所在session，也可以取本页面所在的application的某一属性值；（3）pageContext对象相当于页面中所有功能的集大成者；（4）pageContext对象的本类名也叫pageContext。</code></pre><h5 id="（2）常用方法-1"><a href="#（2）常用方法-1" class="headerlink" title="（2）常用方法"></a>（2）常用方法</h5><pre><code>（1）JspWriter getOut() 返回当前客户端响应被使用的JspWriter流（out）（2）HttpSession getSession() 返回当前页中的HttpSession对象（session）（3）Object getPage() 返回当前页的Object对象（page）（4）ServletRequest getRequest() 返回当前页的ServletRequest对象（request）（5）servletResponse getResponse() 返回当前页的ServletResponse对象（response）（6）void setAttribute(String name,Object attribute) 设置属性及属性值（7）Object getAttribute(String name,int scope) 在指定范围内取属性的值 （8）int getAttributeScope(String name) 返回某属性的作用范围（9）void forward(String relativeUrlPath) 使当前页面重导到另一页面（10）void include(String relativeUrlPath) 在当前位置包含另一文件</code></pre><h4 id="8-page对象"><a href="#8-page对象" class="headerlink" title="8.page对象"></a>8.page对象</h4><hr><p>page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。</p><h5 id="（1）常用方法-1"><a href="#（1）常用方法-1" class="headerlink" title="（1）常用方法"></a>（1）常用方法</h5><pre><code>（1）class getaClass()  返回此Object的类；（2）int hashCode()  返回Object 的hash码；（3）boolean equals(Object obj)  判断此Object 是否与指定的Object对象相等；（4）void copy(Object obj)  把此Object拷贝到指定的Object对象中；（5）Object clone()  克隆此Object对象；（6）String toString()  把此Object对象转换成String类的对象；（7）void notify()  唤醒一个等待的线程；（8）void notifyAll()  唤醒所有等待的线程；（9）void wait(int timeout)  使一个线程处于等待直到timeout结束或被唤醒；（10）void wait()  使一个线程处于等待直到被唤醒；</code></pre><h4 id="9-exception对象"><a href="#9-exception对象" class="headerlink" title="9.exception对象"></a>9.exception对象</h4><hr><p>exception对象是一个异常对象，当一个页面在运行过程中发生了异常，就产生这个对象。作用是显示异常信息，并且只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。</p><h5 id="（1）常用方法-2"><a href="#（1）常用方法-2" class="headerlink" title="（1）常用方法"></a>（1）常用方法</h5><pre><code>（1）String getMessage() 返回描述异常的消息；（2）String toString() 返回关于异常的简短描述消息；（3）void printStackTrace() 显示异常及其栈轨迹；（4）Throwable FillInStackTtace() 重写异常的执行栈轨迹；</code></pre><h4 id="10-四种属性范围"><a href="#10-四种属性范围" class="headerlink" title="10.四种属性范围:"></a>10.四种属性范围:</h4><hr><pre><code>page(pageContext):只在一个页面中保存属性。 跳转之后无效。request:只在一次请求中有效，服务器跳转之后有效。 客户端跳无效session:再一次会话中有效。服务器跳转、客户端跳转都有效。 网页关闭重新打开无效application:在整个服务器上保存，所有用户都可使用。 重启服务器后无效</code></pre><h4 id="11-表单提交方式（get和post）"><a href="#11-表单提交方式（get和post）" class="headerlink" title="11.表单提交方式（get和post）"></a>11.表单提交方式（get和post）</h4><pre><code>（1）get：以明文的方式通过URL提交数据，数据在URL中可以看到。提交的数据最多不超过2KB。安全性较低但效率比post方式高。适合提交数据量不大，安全性不高的数据。比如：搜索、查询等功能。（2）post：将用户提交的信息封装在HTML HEADER内。适合提交数据量大，安全性高的用户信息。比如：注册、修改、上传等功能。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP中Cookie的使用</title>
    <link href="undefined2019/11/10/JSP%E4%B8%ADcookie%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>2019/11/10/JSP%E4%B8%ADcookie%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="JSP中的Cookie用于存储web页面的用户信息"><a href="#JSP中的Cookie用于存储web页面的用户信息" class="headerlink" title="JSP中的Cookie用于存储web页面的用户信息"></a>JSP中的Cookie用于存储web页面的用户信息</h2><h4 id="1-什么是cookie"><a href="#1-什么是cookie" class="headerlink" title="1.什么是cookie"></a>1.什么是cookie</h4><p>​        Cookie（客户端，不是内置对象）：是由服务端生成的，再发送给客户端保存。相当于本地缓存的作用（客户端 ——&gt; 服务端）。</p><p>​        Cookie是服务器发送给浏览器的体积非常小的纯文本信息，用户以后访问同一个Web服务是浏览器会把它们原样发送给服务器。</p><p>​        Cookie对象用于保存客户端浏览器请求的服务器页面，也可用于存放非敏感性的用户信息，信息保存的时间可以根据用户的需要进行设置。并非所有的浏览器都支持Cookie，并且数据信息是以文本的形式保存在客户端计算机中的。</p><p>（1）Cookie是一种浏览器和服务器交互数据的方式。<br>（2）Cookie是由服务器端创建，但是不会保存在服务器。<br>（3）创建好之后，发送给浏览器。浏览器保存在用户本地。<br>（4）下一次访问网站的时候，就会把该Cookie发送给服务器。</p><h5 id="cookie原理示意图"><a href="#cookie原理示意图" class="headerlink" title="cookie原理示意图"></a>cookie原理示意图</h5><p><img src="E:%5Chexo%5Cblog%5Csource%5Cimg%5Ca.png" srcset="/img/loading.gif" alt></p><h4 id="2-JSP中session与cookie的区别"><a href="#2-JSP中session与cookie的区别" class="headerlink" title="2.JSP中session与cookie的区别"></a>2.JSP中session与cookie的区别</h4><p>（1）session是在<a href="https://www.baidu.com/s?wd=服务器端&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">服务器端</a>保存用户信息，客户端不知道其中的信息cookie是在客户端保存信息，服务器能够知道其中的信息。；<br>（2）session中保存的是对象,cookie中保存的是字符串;<br>（3）session对象随会话结束而结束，cookie可以长期保存在客户端；<br>（4）cookie通常用于保存不重要的用户信息，重要的信息使用session保存.</p><h4 id="3-cookie的作用有以下方面："><a href="#3-cookie的作用有以下方面：" class="headerlink" title="3.cookie的作用有以下方面："></a>3.cookie的作用有以下方面：</h4><p>（1） 记录访客的某些信息。例如可以利用cookie记录用户光临的网页次数，或者访客曾经输入过的信息。某些网站可以自动记录用户上次登录的用户名，用的就是cookie。</p><p>（2）页面之间传递变量。浏览器并不会保存当前页面上任何变量的信息，当页面被关闭时，页面上的所有变量信息将随之消失。</p><p>（3）存储用户在网页上的登陆信息，包括账号和密码。</p><p>（4）有的网站，登陆的时候，会出现一个选项，问你是否要一周内或者一个月内保持登陆状态。如果你选了，那么一周之内，都不需要再输入账号密码。这个功能，就是靠cookie来实现的</p><p>（5）提高访问服务端的效率，但是安全性较差。</p><p>（6）用于记录网站的浏览人数，登录次数。</p><p>（7）用于按照用户喜欢设计网页外观，就是具体的网页主题等。</p><p>（8）实现购物车功能。</p><p>注意：其主要思想就是记录下用户前面登录后的信息。</p><h4 id="4-Cookie的产生"><a href="#4-Cookie的产生" class="headerlink" title="4.Cookie的产生"></a>4.Cookie的产生</h4><p>（1）Cookie中保存的数据形式：key，value。</p><p>（2）由Javax.servlet.http.Cookie类产生。</p><h4 id="5-Cookie常见方法"><a href="#5-Cookie常见方法" class="headerlink" title="5.Cookie常见方法"></a>5.Cookie常见方法</h4><pre><code class="jsp">public Cookie（String name，String value）Cookie构造器​    String getName（）获得key值​    String getValue（）获得value值​    void setMaxAge（int expiry）Cookie最大有效期​    response.addCookie（Cookie cookie）用于服务端产生Cookie​    request。getCookie（Cookie cookie）用于客户端获得Cookie​    setMaxAge(10*60);//设置cookie存活期</code></pre><pre><code>（1）Cookie[] getCookies()         HttpServletRequest          返回一个数组，其中包含客户端通过此请求发送的所有Cookie对象（2）void addCookie(Cookie cookie)           HttpServletResponse        通过cookie把这个值返回到浏览器的内存中(回写)  向响应添加指定的cookie。可以多次调用此方法来设置多个     cookie。（3）Cookie(String name ,String value)          使用cookie的构造函数（4）getName()   　　　　　　　　　　             获取cookie名称</code></pre><h4 id="6-生成Cookie步骤"><a href="#6-生成Cookie步骤" class="headerlink" title="6.生成Cookie步骤"></a>6.生成Cookie步骤</h4><pre><code>（1）服务端准备Cookie：response.addCookie（Cookie cookie）（2）页面跳转（请求转发，重定向）（3）客户端获取Cookie：request.getCookie（）；注意：（1）服务端增加Cookie：request对象，客户端获取对象：response对象     （2）不能直接获取某一对象，只能一次将全部Cookie对象获取到。</code></pre><h4 id="7-cookie的销毁"><a href="#7-cookie的销毁" class="headerlink" title="7.cookie的销毁"></a>7.cookie的销毁</h4><p>没有办法直接销毁cookie，可以通过设置同名的cookie来覆盖原有的cookie，起到销毁的作用，cookie设置存活的时间不能设置为0，有些情况可能0代表永久，1即可，存活1秒</p><h4 id="8-Cookie三个案例"><a href="#8-Cookie三个案例" class="headerlink" title="8.Cookie三个案例"></a>8.Cookie三个案例</h4><h5 id="（1）第一个案例"><a href="#（1）第一个案例" class="headerlink" title="（1）第一个案例"></a>（1）第一个案例</h5><p>通过Cookie实现用户登录成功之后规定时间内再次访问该页面时无需登录</p><p>登录页面Login.jsp</p><pre><code>&lt;form action=&quot;Verification.jsp&quot; method=&quot;post&quot;&gt;    用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;user&quot; /&gt;&lt;br&gt;    密码:&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;pwd&quot; style=&quot;width: 158px&quot; /&gt;&lt;br&gt;         &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;            &lt;!-- 当用户点击提交按钮时将网页信息提交给Verification.jsp验证页面--&gt;&lt;/form&gt;    　&lt;%　　　　Cookie[] cookies = request.getCookies();  //获取所有的Cookie对象            　　　　if (cookies != null) {                　　　　for (int i = 0; i &lt; cookies.length; i++) {　　　　                　　　　//利用循环判断用户是否登录过                    　　　　　　if (&quot;admin&quot;.equals(cookies[i].getName())) {                        　　　　　　response.sendRedirect(&quot;Welcome.jsp&quot;);　　　　                        　　　　　　//登录成功重定向到欢迎页面                    　　　　　　}                　　　　}　　　　　　　　    }　　%&gt;</code></pre><p>验证页面 Verification.jsp</p><pre><code>&lt;%    String name=request.getParameter(&quot;username&quot;);  //获取表单信息    String pwd=request.getParameter(&quot;password&quot;);         if(&quot;admin&quot;.equals(name)&amp;&amp;&quot;123456&quot;.equals(pwd)){　　　　//判断用户名和密码是否匹配             Cookie newCookie=new Cookie(&quot;admin&quot;,name);　　　　//创建cookie对象保存用户             newCookie.setMaxAge(5*60);　　　　　　　　　　　　　//设置cookie的有效时间(单位/秒)             response.addCookie(newCookie);　　　　　　　　　　　　　　　　             response.sendRedirect(&quot;Welcome.jsp&quot;);      //保存完信息跳转到欢迎页面,表示登录成功         }else{             request.getRequestDispatcher(&quot;Login.jsp&quot;).forward(request, response);　　             //验证失败的情况下,转发到登录页面         }%&gt;</code></pre><h5 id="（2）第二个案例"><a href="#（2）第二个案例" class="headerlink" title="（2）第二个案例"></a>（2）第二个案例</h5><p>在项目下的web目录下新建一个Cookie文件夹，response_add.jsp</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;cookie验证页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;%          Cookie cookie1=new Cookie(&quot;zz&quot;,&quot;1111&quot;);          Cookie cookie2=new Cookie(&quot;aa&quot;,&quot;2222&quot;);          //服务端增加cookie          response.addCookie(cookie1);          response.addCookie(cookie2);          //转发cookie给客户端          response.sendRedirect(&quot;result.jsp&quot;);      %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>result.jsp生成cookie</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;%          //客户端获取cookie          Cookie[] cookies=request.getCookies();          //输出cookie          for(Cookie cookie:cookies){              out.println(cookie.getName()+&quot;==&quot;+cookie.getValue());          }      %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图预览：</p><p><img src="E:%5Chexo%5Cblog%5Csource%5Cimg%5C1.png" srcset="/img/loading.gif" alt></p><h5 id="（3）第三个案例"><a href="#（3）第三个案例" class="headerlink" title="（3）第三个案例"></a>（3）第三个案例</h5><p>使用Cookie实现自动登录</p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;; %&gt; &lt;html&gt;&lt;head&gt;&lt;title&gt;frist&lt;/title&gt;&lt;/head&gt;&lt;%--登录页面 --%&gt;&lt;form name=&quot;from&quot; method=&quot;post&quot; action=&quot;success.jsp&quot;&gt;&lt;p align=&quot;center&quot;&gt;用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;密码:&lt;input type=&quot;text&quot; name=&quot;password&quot; &gt;&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;Login&quot; value=&quot;Login&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;autologin&quot;&gt;两周内自动登录&lt;%//首先记录下用户的信息,时候选择自动登录String name = request.getParameter(&quot;name&quot;);String password = request.getParameter(&quot;password&quot;);String autoLogin = request.getParameter(&quot;autoLogin&quot;);//创建新想CookieCookie nameCookie = new Cookie(&quot;name&quot; , name);Cookie passwordCookie = new Cookie(&quot;password&quot; , password);Cookie loginCookie = new Cookie(&quot;autoLogin&quot; , autoLogin);//将Cookie写入客户端response.addCookie(nameCookie);response.addCookie(passwordCookie);response.addCookie(loginCookie);//确定点了两周内自动登录if(autoLogin != null){    nameCookie.setMaxAge(3600 * 7 * 24);    passwordCookie.setMaxAge(3600 * 7 * 24);}//每次登录前查看是否存在Cookie,有则自动跳转到登录成功后的界面Cookie[] cookies = request.getCookies();for(Cookie cookie:cookies){    if(cookie.getName().equals(name) &amp;&amp; cookie.getName().equals(password)) {        response.sendRedirect(&quot;success.jsp&quot;);    } else {        response.sendRedirect(&quot;false.jsp&quot;);    }} %&gt;&lt;/form&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>实现Servlet登录案例</title>
    <link href="undefined2019/11/07/%E5%AE%9E%E7%8E%B0Servlet%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B/"/>
    <url>2019/11/07/%E5%AE%9E%E7%8E%B0Servlet%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="实现Servlet登录功能"><a href="#实现Servlet登录功能" class="headerlink" title="实现Servlet登录功能"></a>实现Servlet登录功能</h2><h4 id="一-首先要实现Servlet"><a href="#一-首先要实现Servlet" class="headerlink" title="一.首先要实现Servlet"></a>一.首先要实现Servlet</h4><p>（1）index.jsp</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%    String path = request.getContextPath();    String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort()            + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;title&gt;My JSP &#39;index.jsp&#39; starting page&lt;/title&gt;&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;&lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;&lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;center&gt;        &lt;form action=&quot;&lt;%=basePath%&gt;servlet/UserLoginServlet&quot; method=&quot;post&quot;&gt;        &lt;/form&gt;    &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(2)web.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt;  &lt;display-name&gt;UserLoginDemo&lt;/display-name&gt;  &lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;UserLoginServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.jdbc.login.UserLoginServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;UserLoginServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/servlet/UserLoginServlet&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="二-具体实现"><a href="#二-具体实现" class="headerlink" title="二.具体实现"></a>二.具体实现</h4><p>(1)在WebContent中创建index.jsp</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%    String path = request.getContextPath();    String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort()            + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;title&gt;My JSP &#39;index.jsp&#39; starting page&lt;/title&gt;&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;&lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;&lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;&lt;!--    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;    --&gt;&lt;/head&gt;&lt;body&gt;    &lt;center&gt;        &lt;form action=&quot;&lt;%=basePath%&gt;servlet/UserLoginServlet&quot; method=&quot;post&quot;&gt;            &lt;table border=&quot;1px&quot; width=&quot;438px&quot;&gt;                &lt;tr align=&quot;center&quot;&gt;                    &lt;td&gt;用户名&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr align=&quot;center&quot;&gt;                    &lt;td&gt;密码&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr align=&quot;center&quot;&gt;                    &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;用户登录&quot;&gt; &lt;input                        type=&quot;reset&quot; value=&quot;重置内容&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）在Java Resources—&gt;src—&gt;com.jdbc.login创建.java文件</p><p>1.JdbcUtil.java文件</p><pre><code class="java">package com.jdbc.login;import java.sql.Connection;import java.sql.DriverManager;public class JdbcUtil {    private static String  driver =&quot;com.mysql.jdbc.Driver&quot;;// 数据库驱动类    private static String  url =&quot;jdbc:mysql://localhost:3306/usermanager&quot;;// 数据库链接    private static String  user =&quot;root&quot;;// 数据库用户名    private static String  password =&quot;123456&quot;;// 数据库密码    // 权限修饰符  静态修饰符   返回值类型  方法名称    /**     * 获取链接的     * @return conn     */    public static Connection getConnection() {        try {            //1. 类加载            Class.forName(driver);            //2. 驱动管理获取链接\三个参数\  接收            Connection conn = DriverManager.getConnection(url, user, password);            return conn;        } catch (Exception e) {            throw new RuntimeException(e);        }    }    // TODO 关闭链接没写}</code></pre><p>2.User.java文件</p><pre><code class="java">package com.jdbc.login;public class User {    private Integer id;    private String username;    private String password;    private String sex;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }    @Override    public String toString() {        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot;                + password + &quot;, sex=&quot; + sex + &quot;]&quot;;    }}</code></pre><p>（3）UserDao.java文件</p><pre><code class="java">package com.jdbc.login;public interface UserDao {    /**     * 用户登录功能     * @param username 参数  为用户名     * @param password 参数 为密码     * @return  user     */    User login(String username , String password);}</code></pre><p>（4）UserDaoImple.java文件</p><pre><code class="java">package com.jdbc.login;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class UserDaoImpl implements UserDao {    @Override    public User login(String username, String password) {        // TODO Auto-generated method stub        try {            Connection con = JdbcUtil.getConnection();            Statement st = con.createStatement();            ResultSet rs = st                    .executeQuery(&quot;select * from  user  where username = &#39;&quot;                            + username + &quot;&#39;  and password = &#39;&quot; + password                            + &quot;&#39;;&quot;);            if (rs.next()) {                User user = new User();                user.setUsername(rs.getString(&quot;username&quot;));                user.setPassword(rs.getString(&quot;password&quot;));                System.out.println(&quot;userDao中的user的内容是&quot; + user);                return user;            } else {                return null;            }        } catch (SQLException e) {            // throw new UserLoginException();        }        return null;    }}</code></pre><p>（5）UserLoginServlet.java文件</p><pre><code class="java">package com.jdbc.login;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * servlet相应的java代码 */public class UserLoginServlet extends HttpServlet {    /**     *      */    private static final long serialVersionUID = 1L;    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        /*         * 1 改变编码格式         */        response.setContentType(&quot;text/html&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        request.setCharacterEncoding(&quot;utf-8&quot;);        /*         * 2. 获取jsp界面输入的账号和密码         */        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;password&quot;);        /*         * 3. 将获取到的用户名和密码传递给 userService!         * 所以 得有  userService  没有  怎么  办?  实例化  就有了          */        UserService userService = new UserServiceImpl();        User u = userService.userLogin(username, password);        if(u == null){            response.getWriter().write(&quot;您的用户名或密码有误，请检查！&quot;);        }else{            response.getWriter().write(&quot;用户登录成功！&quot;);        }    }    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet( request,  response);    }}</code></pre><p>（6）UserService.java文件</p><pre><code class="java">package com.jdbc.login;public interface UserService {     /**     * 用户登录功能     * @param username 参数  为用户名     * @param password 参数 为密码     * @return  user     */    User userLogin(String username , String password);}</code></pre><p>（7）UserServiceImpl.java文件</p><pre><code class="java">package com.jdbc.login;public class UserServiceImpl implements UserService {   // 采用多态的形式进行实例化dao     UserDao dao = new  UserDaoImpl();   @Override   public User userLogin(String username, String password) {       //dao代表的是UserDao 这个接口       //.login  用这个接口中的用户登录功能  并且传了两个参数给你       return dao.login(username, password);   }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Request与Cookie对象的常用方法案例</title>
    <link href="undefined2019/11/03/Request%E4%B8%8ECookie%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%A1%88%E4%BE%8B/"/>
    <url>2019/11/03/Request%E4%B8%8ECookie%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Request与Cookie对象案例"><a href="#Request与Cookie对象案例" class="headerlink" title="Request与Cookie对象案例"></a>Request与Cookie对象案例</h2><h3 id="Request案例代码："><a href="#Request案例代码：" class="headerlink" title="Request案例代码："></a>Request案例代码：</h3><p>（1）index.jsp</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;NewFile.jsp&quot; meshod=&quot;post&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;        多选：&lt;br&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;唱&quot;&gt;唱        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;跳&quot;&gt;跳        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;rap&quot;&gt;rap        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;篮球&quot;&gt;篮球        &lt;br&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;input type=&quot;reset&quot; name=&quot;reset&quot; value=&quot;取消&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）NewFile.jsp</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;% request.setCharacterEncoding(&quot;UTF-8&quot;);String name=request.getParameter(&quot;user&quot;);String pwd=request.getParameter(&quot;password&quot;);String [] y=request.getParameterValues(&quot;dx&quot;);%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    用户名是：&lt;%=name %&gt;&lt;br&gt;    密码是：&lt;%=pwd %&gt;&lt;br&gt;    信息来源是：&lt;% for(int i=0;i&lt;y.length;i++){        out.println(y[i]);    } %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="Cookie对象案例："><a href="#Cookie对象案例：" class="headerlink" title="Cookie对象案例："></a>Cookie对象案例：</h2><p>1.自动登录</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;登录页面&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;%     String username =&quot;&quot;;     //读取所有cookie ，返回cookie数组     Cookie[] cookies = request.getCookies();     //遍历cookies数组     if(cookies !=null){        for(int i=0;i&lt;cookies.length;i++){            Cookie cookie = cookies[i];            //根据cookie名称进行判断            if(cookie.getName().equals(&quot;username&quot;)){               //如果能够读取到名称为username的cookie就意味着已经登录过               //就不再进行登录验证，之后转到欢迎页面               response.sendRedirect(&quot;welcome.jsp&quot;);                        }        }     }   %&gt;     &lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;login_action.jsp&quot;&gt;     &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;saveMessage&quot;&gt;两周内自动登录&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;      &lt;/table&gt;     &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>2.欢迎界面</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;欢迎页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;%     String username = &quot;&quot;;     //读取所有cookie，返回cookie数组     Cookie[] cookies = request.getCookies();     for(int i=0;i&lt;cookies.length;i++){         Cookie cookie = cookies[i];         if(cookie.getName().equals(&quot;username&quot;)){             username = cookie.getValue();         }     }     %&gt;        欢迎你：&lt;%=username %&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>3.设置自动记住密码时长</p><pre><code class="jsp">&lt;%@page import=&quot;com.news.entity.User&quot;%&gt;&lt;%@page import=&quot;com.news.dao.IUserDao&quot;%&gt;&lt;%@page import=&quot;com.news.dao.impl.UserDaoImpl&quot;%&gt;&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;登录信息处理&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;%  //获取用户输入      String username = request.getParameter(&quot;username&quot;);      String userpwd = request.getParameter(&quot;pwd&quot;);      String saveMessage = request.getParameter(&quot;saveMessage&quot;);      //对账号和密码进行判断      IUserDao userDao = new UserDaoImpl();      if(userDao.queryUserByUsernameAndUserpwd(new User(username,userpwd))){         //如果用户选中了两周内自动登录，写入cookie         if(saveMessage!=null){            Cookie cookie = new Cookie(&quot;username&quot;,username);            //设置cookie有效期为两周            cookie.setMaxAge(60*60*24*14);            //把cookie写入客户端            response.addCookie(cookie);         }         response.sendRedirect(&quot;welcome.jsp&quot;);      }else{         response.sendRedirect(&quot;login_error.jsp&quot;);      }    %&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自学PS</title>
    <link href="undefined2019/11/02/%E8%87%AA%E5%AD%A6PS/"/>
    <url>2019/11/02/%E8%87%AA%E5%AD%A6PS/</url>
    
    <content type="html"><![CDATA[<h2 id="PS基础"><a href="#PS基础" class="headerlink" title="PS基础"></a>PS基础</h2><p>直接拉进来<br>ctrl+t图片放大放小自由变换<br>shirt等比例方大</p><p>ctrl+shirt+i反选/鼠标右键选择反选<br>ctrl+d取消选取</p><p>c+s+u去色<br>ctrl+j复制图层<br>ctrl+i反向</p><p>滤镜里面的液化可以把脸修瘦</p><img src="E:\hexo\blog\source\img\01.jpg" srcset="/img/loading.gif">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Eclipse连接Mysql数据库</title>
    <link href="undefined2019/11/01/Eclipse%E8%BF%9E%E6%8E%A5Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/11/01/Eclipse%E8%BF%9E%E6%8E%A5Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Eclipse连接数据库步骤"><a href="#Eclipse连接数据库步骤" class="headerlink" title="Eclipse连接数据库步骤"></a>Eclipse连接数据库步骤</h2><h5 id="1、先下载JDBC："><a href="#1、先下载JDBC：" class="headerlink" title="1、先下载JDBC："></a>1、先下载JDBC：</h5><p>JDBC代表Java数据库连接(<strong>J</strong>ava <strong>D</strong>ata<strong>b</strong>ase <strong>C</strong>onnectivity)，它是用于Java编程语言和数据库之间的数据库无关连接的标准Java API，换句话说：JDBC是用于在Java语言编程中与数据库连接的API。</p><p>到<a href="http://www.mvnrepository.com" target="_blank" rel="noopener">www.mvnrepository.com</a></p><h5 id="2、打开ECLIPSE-创建一个DYNAMIC-WEB-PROJECT项目"><a href="#2、打开ECLIPSE-创建一个DYNAMIC-WEB-PROJECT项目" class="headerlink" title="2、打开ECLIPSE,创建一个DYNAMIC WEB PROJECT项目"></a>2、打开ECLIPSE,创建一个DYNAMIC WEB PROJECT项目</h5><p>在lib中插入mysql-connector文件</p><h5 id="3-打开-NEWFILE-JSP文件"><a href="#3-打开-NEWFILE-JSP文件" class="headerlink" title="3.打开 NEWFILE.JSP文件"></a>3.打开 NEWFILE.JSP文件</h5><p>插入下面代码 更改相应信息即可</p><pre><code class="jsp">&lt;%    String driver = &quot;com.mysql.jdbc.Driver&quot;;    // URL指向要访问的数据库名test1    String url = &quot;jdbc:mysql://localhost:3306/schooldb&quot;;    // MySQL配置时的用户名    String user = &quot;root&quot;;    // Java连接MySQL配置时的密码    String password = &quot;123456&quot;;    try {        // 1 加载驱动程序        Class.forName(driver);        // 2 连接数据库        Connection conn = DriverManager.getConnection(url, user, password);        // 3 用来执行SQL语句        Statement statement = conn.createStatement();        // 要执行的SQL语句        String sql = &quot;select * from stuinfo&quot;;        ResultSet rs = statement.executeQuery(sql);        String name = null;        String mima = null;        String mima2 = null;        while (rs.next()) {            name = rs.getString(&quot;name&quot;);            mima = rs.getString(&quot;score&quot;);            mima2 = rs.getString(&quot;rank&quot;);            out.println(name + &quot;\t&quot; + mima + &quot;\t&quot; + mima2);        }        rs.close();        conn.close();    } catch (ClassNotFoundException e) {        System.out.println(&quot;Sorry,can`t find the Driver!&quot;);        e.printStackTrace();    } catch (SQLException e) {        e.printStackTrace();    } catch (Exception e) {        e.printStackTrace();    }%&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Github博客搭建步骤</title>
    <link href="undefined2019/10/31/Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/"/>
    <url>2019/10/31/Github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Github个人技术博客搭建步骤"><a href="#Github个人技术博客搭建步骤" class="headerlink" title="Github个人技术博客搭建步骤"></a>Github个人技术博客搭建步骤</h1><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><p>1、GitHub账号</p><p>注册地址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>2、Node.js环境</p><p>下载地址：<a href="https://nodejs.org/download/" target="_blank" rel="noopener">https://nodejs.org/download/</a></p><p>3、Git 软件：下载地址<a href="http://git-scm.com/download/" target="_blank" rel="noopener">http://git-scm.com/download/</a></p><h3 id="二、软件安装"><a href="#二、软件安装" class="headerlink" title="二、软件安装"></a>二、软件安装</h3><p>1、注册GitHub账号</p><p>1)Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，此处账号名作为后期个人博客的地址使用2。并且需要勾选Initialize this repository with a README。（如果没有勾选，后期要创建README文件即可）</p><p>2)创建一个新的repository(代码仓库), 注意，名称必须是xxx.github.io 格式，并且xxx必须是你在GitHub的用户名。</p><p>3)在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，可以访问它。你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。</p><p>2.安装Node.js</p><p>在node.js指定地址下载，采用最新的版本即可。</p><ol><li>安装Git.</li></ol><h3 id="三、Hexo配置流程"><a href="#三、Hexo配置流程" class="headerlink" title="三、Hexo配置流程"></a>三、Hexo配置流程</h3><p>1、<strong>安装Hexo</strong></p><p>Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。</p><p>1）新建文件夹hexo</p><p>首先创建一个文件夹，用来存放Hexo模板和项目，然后进入 hexo 文件夹，鼠标右键点击Git Bash Here。</p><p>2）安装hexo基础框架</p><p>// 这是安装hexo的基础框架（此处要求已经安装了node.js环境）</p><p>第一步：<code>npm install hexo-cli -g</code></p><p>第二步：`hexo init blog ```</p><p>它就会在当前目录下生成一个blog的文件夹，并在里面生成相关配置信息。</p><p>第三步：<code>cd blog</code></p><p>切换到blog目录下</p><p>第四步：<code>npm install</code></p><p>安装必备的组件，安装完成之后，<code>blog</code>文件夹的目录结构大致如下：</p><p>// 编译生成静态页面，会在当前目录下生成一个新的叫做public的文件夹。</p><p>第五步：<code>hexo g</code></p><p>``</p><p>// 启动本地服务</p><p>第六步：<code>hexo s</code></p><p>``</p><p>打开链接<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>，看到这样的网页就成功啦。</p><pre><code></code></pre><p>2、 hexo主题设置，这里以主题yilia为例进行说明。</p><p>1）安装主题（此处当前目录为blog）</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p><p>2）启用主题</p><p>cd themes/yilia</p><p>git pull //获取远程内容</p><p>3） 修改配置文件</p><p>修改hexo目录下的_config.yml配置文件中的theme属性，将其设置为我们前面克隆下来的主体样式，此处theme: yilia</p><p>4） 重启服务</p><p>切换到blog目录</p><p>hexo g # 重新生成静态文件</p><p>hexo s # 启动本地web服务器</p><p>现在打开<a href="http://localhost:4000，会看到我们已经应用了一个新的主题。/" target="_blank" rel="noopener">http://localhost:4000，会看到我们已经应用了一个新的主题。</a></p><h3 id="四、部署到GitHub服务器"><a href="#四、部署到GitHub服务器" class="headerlink" title="四、部署到GitHub服务器"></a>四、部署到GitHub服务器</h3><p>1、使用git命令行部署（optional）</p><p>此处我们采用git命令来完成部署的工作。</p><p>1) cd d:/hexo/blog</p><p>git clone <a href="https://github.com/fang235/fang235.github.io" target="_blank" rel="noopener">https://github.com/cuihuniubi/cuihuniubi.github.io</a> .deploy/cuihuniubi.github.io</p><p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。</p><p>2) hexo generate //生成静态文件</p><p>cp -R public/* .deploy/cuihuniubi.github.io //复制文件</p><p>cd .deploy/cuihuniubi.github.io //切换目录</p><p>git add . //将需要提交的代码添加到暂存区</p><p>git commit -m “update” //将暂存区内容提交给本地版本库</p><p>git push //推送给远程服务器</p><p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至cuihuniubi.github.io的git目录下，然后使用git commit命令提交代码到cuihuniubi.github.io这个repo的master branch上。</p><p>需要部署的时候，执行第三个步骤。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p><p>2、 验证</p><p>打开浏览器，输入地址：<a href="https://cuihuniubi.github.io/" target="_blank" rel="noopener">https://cuihuniubi.github.io/</a> ，就可以看到我们的博客上线了哈哈哈！！！</p><h3 id="五、发布博客内容"><a href="#五、发布博客内容" class="headerlink" title="五、发布博客内容"></a>五、发布博客内容</h3><p>1、创建博客标题</p><p>hexo new “CUIHUNIUBI”</p><p>2、编写博客内容</p><p>找到创建的md文件，使用编辑器打开，按照Markdown的格式，编写博客内容，编写完成之后，执行以下代码，将博客内容推送到远程服务器上。</p><p>hexo generate //生成静态文件</p><p>cp -R public/* .deploy/cuihuniubi.github.io //复制文件</p><p>cd .deploy/cuihuniubi.github.io //切换目录</p><p>git add . //将需要提交的代码添加到暂存区</p><p>git commit -m “update” //将暂存区内容提交给本地版本库</p><p>git push //推送给远程服务器</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA面向对象知识点总结</title>
    <link href="undefined2019/10/30/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/30/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章面向对象"><a href="#第二章面向对象" class="headerlink" title="第二章面向对象"></a>第二章面向对象</h2><p>1.面向对象：面向对象思想就是把一个项目，一件事情分成更小的项目，每一部分负责什么功能，最后再有这些部分组合成一个整体。</p><p>2.类的创建</p><pre><code class="java">    语法：public class 类名{}​      File---&gt;new---&gt;class---&gt;类名</code></pre><p>​      </p><p>3.创建对象</p><pre><code>类名 对象名=new 类名();​      对象名.方法名(); 对象名.属性</code></pre><p>4.构造方法：方法名和类名相同,没有返回值</p><pre><code>     public class 类名{​         public 类名(){}//主要的做用是初始化操作​      }</code></pre><p>5.构造方法重载</p><p>（1）构造方法的重载：方法名与类名相同，参数列表不同</p><p>（2）方法的重载：在同一个类中包含了两个或者两个以上的方法，它们的方法名相同，方法的参数个数，顺序，类型不同，则称这个方法被重载了，这个过程称为方法的重载。</p><p>（3）构造方法的作用：用来实现多种初始化行为。</p><pre><code>    public class 类名{​         public 类名(){}​         public 类名(String name,int age){}​      }</code></pre><p>6.构造方法的执行</p><pre><code>     new 类名();---&gt;执行构造方法​      super();---&gt;执行了父类的构造方法</code></pre><p>7.static静态修饰符</p><p>   （1）含义：static可以用来修饰属性，方法，和代码块。static修饰的变量属于这个类所有，即由这个类创建的所有对象共用一个static变量。通常把static修饰的属性和方法称为类属性（也可以称为类变量），类方法。不使用static修饰的属性和方法属于单个对象，通常称为实例属性，实例方法。</p><p>（2）要点：</p><p>​    1.在加载类的过程中，完成静态变量的内存分配，再执行静态代码块，两者是在创建对象之前执行的。</p><p>​    2.类属性和类方法可以通过类名和对象名访问，实例属性和实例方法只能通过对象名访问。</p><p>​    3.类方法只能访问类属性和其他类方法，</p><p>注意：静态方法中不能使用this和super关键字。</p><p>8.java内存（栈和堆，static，方法区，gc（垃圾回收机制））</p><p>9.八种基本数据类型：</p><pre><code>    byte  short   int   long    float   double   Boolean   char</code></pre><h2 id="第三章面向对象三大特征—封装"><a href="#第三章面向对象三大特征—封装" class="headerlink" title="第三章面向对象三大特征—封装"></a>第三章面向对象三大特征—封装</h2><h3 id="第三章-面向对象三大特征—封装"><a href="#第三章-面向对象三大特征—封装" class="headerlink" title="第三章 面向对象三大特征—封装"></a>第三章 面向对象三大特征—封装</h3><p>1.封装的概念：封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部的信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>2.封装的步骤</p><p>​      1.把属性私有化（private）</p><p>​      2.对这些属性设置get和set方法</p><p>​      3.调用处理这些方法</p><p>3.封装的作用与好处：</p><p>作用：避免一些用一些不合乎常理的操作</p><p>好处：</p><p>（1） 提高了安全性</p><p>（2） 提高了复用性</p><p>（3） 隐藏了实现细节</p><p>4.封装的案例:</p><pre><code class="java">/* 文件名: EncapTest.java */public class EncapTest{   private String name;   private String idNum;   private int age;   public int getAge(){​      return age;   }   public String getName(){​      return name;   }   public String getIdNum(){​      return idNum;   }   public void setAge( int newAge){​      age = newAge;   }   public void setName(String newName){​      name = newName;   }   public void setIdNum( String newId){​      idNum = newId;   }}/* F文件名 : RunEncap.java */public class RunEncap{   public static void main(String args[]){​      EncapTest encap = new EncapTest();​      encap.setName(&quot;James&quot;);​      encap.setAge(20);​      encap.setIdNum(&quot;12343ms&quot;);​      System.out.print(&quot;Name : &quot; + encap.getName()+ ​                             &quot; Age : &quot;+ encap.getAge());​    }}</code></pre><p>5.修饰符</p><p>​      public—&gt;公共的：在一个项目中都可以访问，权限最高</p><p>​      private—&gt;私有的：只能在本类中进行访问，权限最低</p><p>​      protected—&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类</p><p>​      default—&gt;默认的：同一个包能访问</p><h2 id="第四章-面向对象三大特征—继承"><a href="#第四章-面向对象三大特征—继承" class="headerlink" title="第四章 面向对象三大特征—继承"></a>第四章 面向对象三大特征—继承</h2><p>1.继承的概念：父亲儿子</p><p>2.继承的关键字：extends</p><p>3.继承的好处：</p><p>   （1）提高了代码的重用性</p><p>   （2）提高了代码的可扩展性</p><p>3.继承的语法：</p><pre><code>     public class 类名  extends 父类{    代码块   }</code></pre><p>4.继承的使用与说明：</p><p>   （1）使用：</p><p>可以直接调用父类的非私有属性和方法</p><p>​         可以用super.方法     super.属性</p><p>   （2）说明： Java中的继承只能单继承，</p><p>5.父类构造方法调用：super();</p><p>​     //super指代的是父类对象，this指代的是本类对象</p><p>​      调用父类的构造方法必须在之类中调用</p><p>​      必须实在之类构造方法的第一行代码</p><p>6.继承中的构造方法要点：</p><p>   （1）执行子类的构造方法，会默认执行父类的无参构造方法</p><p>  （2）当子类没有无参构造方法，但是有有参构造方法,子类的构造方法需手动添加</p><p>  （3）父类没有定义无参构造方法，定义了带参构造方法，子类的构造方法必须调用父类的带参构造方法。</p><p>  （4）无论是super还是this调用构造方法，只能放在第一行，构造方法只能调用一个</p><p>  （5）构造方法只能在构造方法中调用</p><p>7.重写@Override</p><p>​      必须继承</p><p>​      方法名一致，参数个数，顺序，类型全部一致</p><p>8.重载与重写的区别：</p><p>重载:一定发生在同一类中，方法名相同，参数不同（类型不同，数量不同）</p><p>重写：一定发生在父类和子类中，方法名相同，参数相同，方法体不同</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="第五章-面向对象—多态"><a href="#第五章-面向对象—多态" class="headerlink" title="第五章 面向对象—多态"></a>第五章 面向对象—多态</h2><p>1.多态的概念：不同对象对同一消息产生不同的响应。</p><p>2.多态的必要条件</p><p>   （1）继承</p><p>   （2）重写</p><p>   （3）父类引用指向子类对象（向上转型）</p><p>3.多态的优点：</p><p>   （1）消除类型之间的耦合关系</p><p>   （2）可替换性</p><p>   （3）可扩展性</p><p>   （4）接口性</p><p>   （5）灵活性</p><p>   （6）简化性</p><p>3.多态的使用</p><p>   （1）第一个例子</p><pre><code class="java"> public class Father{​         public void cooking(){​            System.out.println(&quot;米饭&quot;);​         }​      }​      public class Son extends Father{​         @Override​         public void cooking(){​            System.out.println(&quot;熬粥&quot;);​         }​      }​      public class Test {​         public static void main(String[] args) {​            Father son=new Son();​            son.cooking();​         }​      }</code></pre><p>   （2）第二个例子</p><pre><code class="java"> public class Test {​    public static void main(String[] args) {​      show(new Cat());  // 以 Cat 对象调用 show 方法​      show(new Dog());  // 以 Dog 对象调用 show 方法​                ​      Animal a = new Cat();  // 向上转型  ​      a.eat();               // 调用的是 Cat 的 eat​      Cat c = (Cat)a;        // 向下转型  ​      c.work();        // 调用的是 Cat 的 work  }  ​            ​    public static void show(Animal a)  {​      a.eat();  ​        // 类型判断​        if (a instanceof Cat)  {  // 猫做的事情 ​            Cat c = (Cat)a;  ​            c.work();  ​        } else if (a instanceof Dog) { // 狗做的事情 ​            Dog c = (Dog)a;  ​            c.work();  ​        }  ​    }  }abstract class Animal {  ​    abstract void eat();  }  class Cat extends Animal {  ​    public void eat() {  ​        System.out.println(&quot;吃鱼&quot;);  ​    }  ​    public void work() {  ​        System.out.println(&quot;抓老鼠&quot;);  ​    }  }  class Dog extends Animal {  ​    public void eat() {  ​        System.out.println(&quot;吃骨头&quot;);  ​    }  ​    public void work() {  ​        System.out.println(&quot;看家&quot;);  ​    }  }</code></pre><p> 4.向上转型（子类向父类的转换）  </p><pre><code> 语法 ：​      &lt;父类型&gt;  &lt;引用变量名&gt; = new  &lt;子类型&gt;（）；​      例如：Animal an1=new Dog（）；</code></pre><p>5.向下转型（必须基于向上转型）</p><pre><code>    例如：Son son=(Son)father;</code></pre><p>6.注意：</p><p>   （1）属性无多态这个属性，只看“=”左边的类型</p><p>   （2）编译时，能“.”出来，能调用的看“=”左边</p><p>7.Instanceof运算符：</p><p>8.异常的处理（Try-catch-finally块）：</p><pre><code>语法：​      Try{​         代码块；}catch（Exception  e）{   代码块；}finally{   代码块；}</code></pre><p>注意：</p><p>（1） catch（Exception  e）一定放在所有catch块的最后</p><p>（2） finally{}块里面的代码一定会执行</p><p>结束的语句：</p><pre><code>   （1）return；   （2）system.exit（0）;</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h2 id="第六章-抽象"><a href="#第六章-抽象" class="headerlink" title="第六章 抽象"></a>第六章 抽象</h2><p>1.抽象的概念:当一个类没有足够的信息去描述一个具体的对象，那么我们称之为抽象类。</p><p>​    （1）在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象                 的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>​    （2）注意：类是对象的描述，对象是类的具体体现</p><p>​    （3）抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问                                      方式和普通类一样。（由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。）</p><p>2.抽象的关键字</p><p>​      abstract</p><p>​      可以修饰类，可以修饰方法</p><p>3.抽象类的作用：</p><p>   （1）抽象类是用来继承的</p><p>   （2）抽象类无法new出对象</p><p>4.抽象的用法</p><pre><code>     //抽象类​      public abstract class 类名{​         //抽象方法没有方法体​         public abstract void 方法名();   ​      }     //当父类是抽象类的时候，子类必须重写父类里面的抽象方法</code></pre><p>​     </p><h4 id="5-抽象方法"><a href="#5-抽象方法" class="headerlink" title="5.抽象方法"></a>5.抽象方法</h4><p>（1）如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><pre><code>public abstract class Employee{   private String name;   private String address;   private int number;   public abstract double computePay();   //其余代码}</code></pre><p>（2）声明抽象方法会造成以下两个结果</p><pre><code>（1）如果一个类包含抽象方法，那么该类必须是抽象类。（2）任何子类必须重写父类的抽象方法，或者声明自身为抽象类。（3）继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</code></pre><p>6.final修饰符：最终的</p><p>   修饰变量，修饰方法，修饰类</p><p>   （1）.当修饰变量时，变量转换成常量，常量的值不能改变</p><p>​      final int a=18;//a=18;不能改变,必须给一个初始值</p><p>   （2）.当修饰方法时，该方法不能被重写</p><p>   （3）.当修饰类时，该类不能被继承</p><h4 id="7-抽象类总结规定"><a href="#7-抽象类总结规定" class="headerlink" title="7.抽象类总结规定"></a>7.抽象类总结规定</h4><pre><code>（1） 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。（4）构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</code></pre><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><p>为什么要用接口？：因为JAVA只支持单继承。</p><ol><li>接口的概念</li></ol><p>2.接口的关键字</p><p>​      interface</p><p>3.接口的语法</p><pre><code>      public interface 接口名{}​      File---&gt;new---&gt;interface//创建接口</code></pre><p>4.接口的实现与用法</p><p>（1）实现</p><pre><code>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</code></pre><p>（2）用法</p><pre><code>      实现接口的关键字  implements​      public interface 接口名{​         //接口是纯抽象类​         //接口里面的方法都是抽象方法​         void setData();​      }​      public class Play implements 接口名{​         @Override​         void setData(){​         }​      }​      public class Test {​         public static void main(String[] args) {​            Play play=new Play();​            play.setData();​         }​      }​      注意接口可以进行多继承​      public interface 接口名 extends 接口名，接口名{}​      一般用法​      public class 类名 extends 父类 implements 接口，接口{}</code></pre><p>多态与接口的区别：</p><p>（1） 多态：难</p><p>（2） 接口：简单，不能随意定义属性和方法，只能定义抽象方法，并且实现对口必须重写。</p><p>5.接口的特性</p><pre><code>（1）接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。（2）接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。（3）接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。（4）接口中的方法都是公有的。</code></pre><p>6.接口和类的区别</p><pre><code>- 接口不能用于实例化对象。- 接口没有构造方法。- 接口中所有的方法必须是抽象方法。- 接口不能包含成员变量，除了 static 和 final 变量。- 接口不是被类继承了，而是要被类实现。- 接口支持多继承。</code></pre><p>7.重写接口中声明的方法时，需要注意以下规则</p><pre><code>（1）类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。（2）类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。（3）如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</code></pre><p>8.在实现接口的时候，也要注意一些规则：</p><pre><code>（1）一个类可以同时实现多个接口。（2）一个类只能继承一个类，但是能实现多个接口。（3）一个接口能继承另一个接口，这和类之间的继承比较相似。（4）接口可以多继承其他接口，不过继承要实现（父类和自己）全部的方法</code></pre><h4 id="9-接口和抽象类的详细区别"><a href="#9-接口和抽象类的详细区别" class="headerlink" title="9.接口和抽象类的详细区别"></a>9.接口和抽象类的详细区别</h4><p>语法层次的区别</p><pre><code> 1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</code></pre><p>设计层面的区别</p><pre><code>1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 &quot;是不是&quot;的关系，而 接口 实现则是 &quot;有没有&quot;的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和 ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。下面看一个网上流传最广泛的例子：门和警报的例子：门都有 open() 和 close() 两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：    第一种：        abstract class Door {                public abstract void open();                public abstract void close();        }    第二种：        interface Door {                public abstract void open();            public abstract void close();        }解答：但是现在如果我们需要门具有报警 的功能，那么该如何实现？下面提供两种思路：1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的 open( ) 和 close( )，也许这个类根本就不具备 open( ) 和 close( ) 这两个功能，比如火灾报警器。从这里可以看出， Door 的 open() 、close() 和 alarm() 根本就属于两个不同范畴内的行为，open() 和 close() 属于门本身固有的行为特性，而 alarm() 属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含 alarm() 行为，Door 设计为单独的一个抽象类，包含 open 和 close 两种行为。再设计一个报警门继承 Door 类和实现 Alarm 接口。</code></pre><h2 id="第八章-集合框架"><a href="#第八章-集合框架" class="headerlink" title="第八章 集合框架"></a>第八章 集合框架</h2><p>1.ArrayList</p><p>  1.用法</p><pre><code>     ArrayList list=new ArrayList();    list.add();//添加数据    list.get();//获取数据</code></pre><p>2.Map的用法：</p><pre><code>       Map map=new HasMap();​      map.put(key,value);//key不能重复​      map.get(key);//获取key对象的value</code></pre><p>3.泛型</p><pre><code>      ArrayList&lt;String&gt; list=new ArrayList&gt;&lt;String&gt;();      Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();      ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL数据库知识点总结</title>
    <link href="undefined2019/10/29/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/29/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Mysql数据库知识点总结"><a href="#Mysql数据库知识点总结" class="headerlink" title="Mysql数据库知识点总结"></a>Mysql数据库知识点总结</h2><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-如何在命令行配置MYSQL数据库"><a href="#1-如何在命令行配置MYSQL数据库" class="headerlink" title="1.如何在命令行配置MYSQL数据库"></a>1.如何在命令行配置MYSQL数据库</h3><p>1）找到MYSQL安装目录的bin目录</p><p>2）放置到path环境变量中</p><h3 id="2-启动停止MYSQL"><a href="#2-启动停止MYSQL" class="headerlink" title="2.启动停止MYSQL"></a>2.启动停止MYSQL</h3><p>启动： netstarmysqla 停止：mysql net stop mysqla</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>binary,int,float,double,char,varchar,text,datetime</p><h3 id="4-添加数据库"><a href="#4-添加数据库" class="headerlink" title="4.添加数据库"></a>4.添加数据库</h3><pre><code class="mysql">create database 数据库名;</code></pre><h3 id="5-查看数据库"><a href="#5-查看数据库" class="headerlink" title="5.查看数据库"></a>5.查看数据库</h3><pre><code class="mysql">show databases;show create database;</code></pre><h3 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6.删除数据"></a>6.删除数据</h3><pre><code>drop database 数据库名;</code></pre><h3 id="7-使用数据库前需要先打开数据表所在的数据库"><a href="#7-使用数据库前需要先打开数据表所在的数据库" class="headerlink" title="7.使用数据库前需要先打开数据表所在的数据库"></a>7.使用数据库前需要先打开数据表所在的数据库</h3><pre><code>use 数据库名;</code></pre><h3 id="8-创建表"><a href="#8-创建表" class="headerlink" title="8.创建表"></a>8.创建表</h3><pre><code>create table 表名(字段1 类型（长度）,[约束]，.....);</code></pre><h3 id="9-查询当前数据库下有哪些表"><a href="#9-查询当前数据库下有哪些表" class="headerlink" title="9.查询当前数据库下有哪些表"></a>9.查询当前数据库下有哪些表</h3><pre><code>show tables;</code></pre><h3 id="10-查询表结构"><a href="#10-查询表结构" class="headerlink" title="10.查询表结构"></a>10.查询表结构</h3><pre><code>sesc student;</code></pre><h3 id="11-据库备份与还原"><a href="#11-据库备份与还原" class="headerlink" title="11.据库备份与还原"></a>11.据库备份与还原</h3><pre><code>mysqldump-uroot-p first-db&gt;C:123456.sql</code></pre><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>1.数据库没有大小写之分</p><p>2.关键词大写，自定义的小写<br>3.修改表内容的关键词</p><pre><code>alter table 表名 （动作）改表名 动作 rename 新表名改字段类型 动作 modify 字段名 新类型改字段名称 动作 change 旧名称 新名称 新类型增加字段 动作 add 新增字段名 新增字段类型删除字段 动作 drop 字段名删除表 drop table 表名;删除数据库 drop database 数据库名;</code></pre><h3 id="1、数据完整性"><a href="#1、数据完整性" class="headerlink" title="1、数据完整性"></a>1、数据完整性</h3><p>主键约束 primary key 特点是非空且唯一<br>两种写法，直接写在字段后，或者写在创建语句最后 primary key（字段名）<br>联合主键 写在创建语句最后 primary key(字段 1，字段 2)</p><h3 id="2、设置字段自增长-auto-increment"><a href="#2、设置字段自增长-auto-increment" class="headerlink" title="2、设置字段自增长 auto_increment"></a>2、设置字段自增长 auto_increment</h3><p>数据表只有一个自增长列，为主键列</p><h3 id="3、外键约束-foreign-key"><a href="#3、外键约束-foreign-key" class="headerlink" title="3、外键约束 foreign key"></a>3、外键约束 foreign key</h3><p>写在创建语句最后 foreign key (从表字段名) references 主表名<br>（主表字段名）</p><h3 id="4、非空约束-not-null"><a href="#4、非空约束-not-null" class="headerlink" title="4、非空约束 not null"></a>4、非空约束 not null</h3><h3 id="5、默认约束-default-值，注意字符串，需外加单引号"><a href="#5、默认约束-default-值，注意字符串，需外加单引号" class="headerlink" title="5、默认约束 default 值，注意字符串，需外加单引号"></a>5、默认约束 default 值，注意字符串，需外加单引号</h3><h3 id="6、唯一约束-unique"><a href="#6、唯一约束-unique" class="headerlink" title="6、唯一约束 unique"></a>6、唯一约束 unique</h3><p>主键约束和唯一约束的区别，主键无意义，唯一约束可以为 null<br>设计规范<br>1NF（第一范式）保证数据列的原子性<br>家庭住址 可分为省 市 县 具体地址<br>2NF 保证每列都和主键相关（唯一主键，联合主键不满足）<br>学号 姓名 课程 教材 教材内容<br>1 张三 数据库 mysql XXXXX（1 千字）<br>1 张三 java java<br>2 李四 数据库 mysql XXXXX（1 千字）<br>3 王五 数据库 mysql XXXXX（1 千字）<br>数据冗余 更新异常 插入异常 删除异常</p><p>3NF 保证每列都和主键直接相关<br>学号 姓名 班级 辅导员编号 辅导员姓名 辅导员家庭住址</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="数据库的增删改操作"><a href="#数据库的增删改操作" class="headerlink" title="数据库的增删改操作"></a>数据库的增删改操作</h3><h3 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h3><pre><code>insert into 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；查询数据select * from 表名;</code></pre><h3 id="2、into-关键字可以省略"><a href="#2、into-关键字可以省略" class="headerlink" title="2、into 关键字可以省略"></a>2、into 关键字可以省略</h3><pre><code>简写形式 insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。）；</code></pre><h3 id="3、全列插入可省略列明"><a href="#3、全列插入可省略列明" class="headerlink" title="3、全列插入可省略列明"></a>3、全列插入可省略列明</h3><pre><code>简写形式 insert 表名 values（值 1，值 2，。。。）；</code></pre><h3 id="4、自增列和默认列可省略"><a href="#4、自增列和默认列可省略" class="headerlink" title="4、自增列和默认列可省略"></a>4、自增列和默认列可省略</h3><p>注意：自增列只增不减<br>除非：alter table 表名 set auto_increment=值;<br>或者 truncate table 表名; 清空表，自增从 1 开始记数</p><h3 id="5、一次插入多行"><a href="#5、一次插入多行" class="headerlink" title="5、一次插入多行"></a>5、一次插入多行</h3><pre><code>insert 表名（列 1，列 2，。。。） values（值 1，值 2，。。。），（值 1，值 2，。。。），。。。。；</code></pre><h3 id="6、比较运算"><a href="#6、比较运算" class="headerlink" title="6、比较运算"></a>6、比较运算</h3><p>大于&gt;=大于等于&lt;小于&lt;=小于等于 =等于 !=或&lt;&gt;不等于</p><p>is null 为空 is not null 非空 in 在某个范围 not in 不在某个范<br>围 like 模糊查询 between and 在某个范围</p><h3 id="7、逻辑运算"><a href="#7、逻辑运算" class="headerlink" title="7、逻辑运算"></a>7、逻辑运算</h3><p>not 非 and 并且 or 或者</p><h3 id="8、修改数据"><a href="#8、修改数据" class="headerlink" title="8、修改数据"></a>8、修改数据</h3><pre><code>update 表名 set 列名 1=值 1，列名 2=值 2… where 条件;</code></pre><p>如果没有 where 全更新</p><h3 id="9、删除数据"><a href="#9、删除数据" class="headerlink" title="9、删除数据"></a>9、删除数据</h3><pre><code>delete from 表名 where 条件; </code></pre><p>注意删除数据不更改自增列的值</p><h3 id="10、清空数据"><a href="#10、清空数据" class="headerlink" title="10、清空数据"></a>10、清空数据</h3><p>truncate table 表名功能同 delete from 表名<br>但是<br>1&gt;Delete 无法修改自增列，truncate 重置自增列<br>2&gt;Delete 可以删除外键约束，truncate 只能清空数据，无法删除外<br>键约束<br>3&gt;Delete 可以通过备份和日子恢复，truncate 无法恢复</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><strong>注意：</strong><br>1、数据库没有双引号，字符一定要用单引号包括<br>2、字段名不用引号，单引号包括的一定是字符<br>``(数字键 1 左边的键)</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>select 字段 1、字段 2… from 表名 where 条件 order by 字段 1、<br>字段 2.. limit 数字 1,数字 2;<br>*是通配符，表示所有字段<br>使用 as 为字段重命名</p><h3 id="3、where-查询条件"><a href="#3、where-查询条件" class="headerlink" title="3、where 查询条件"></a>3、where 查询条件</h3><h3 id="4、distinct-查询不重复字段"><a href="#4、distinct-查询不重复字段" class="headerlink" title="4、distinct 查询不重复字段"></a>4、distinct 查询不重复字段</h3><h3 id="5、limit-n-m"><a href="#5、limit-n-m" class="headerlink" title="5、limit n,m"></a>5、limit n,m</h3><p>从 n+1 行开始取，取 m 行，行数从 0 开始<br>limit n,取前 n 行</p><h3 id="6、order-by-字段-1"><a href="#6、order-by-字段-1" class="headerlink" title="6、order by 字段 1"></a>6、order by 字段 1</h3><p>通过字段 1 将表从小到大排列<br>order by 字段 1 desc<br>order by 字段 1,字段 2<br>先按照字段 1 排列，在字段 1 相同的情况下按照字段 2 排列</p><p>成绩表，姓名，成绩<br>查询一下第 3 到 6 的女学生姓名<br>select 姓名 from 成绩表 where 性别=’女’ order by 成绩 desc<br>limit 2,4;<br>MySQL 函数<br>concat(‘今天’,’晴天’) 拼接字符串<br>length(‘hello world’) 计算长度，一个字符，符号，数字占 1 位，<br>一个汉字占 3 位<br>upper(‘abcd’) 转成大写<br>ltrim(‘ abc’) 清除左侧空格<br>rtrim(‘abc ‘) 清除右侧空格<br>trim(‘ abc ‘) 清除两侧空格<br>replace(‘abccd’,’c’,’x’) 将 abccd 中的所有 c 替换成 x<br>strcmp(‘a’,’b’) 比较字符串大小<br>substring(‘abcdefg’,3,3) 取子串，从第 3 个开始取，取 3 个<br>数学函数<br>rand(); 取 0~1 的随机小数，取不到 0 和 1<br>ceil();向上取整<br>floor(); 向下取整</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="模糊查询和分组查询"><a href="#模糊查询和分组查询" class="headerlink" title="模糊查询和分组查询"></a>模糊查询和分组查询</h3><p>模糊查询使用 like 关键字， _代表一个字符 ，%代表任意长度的字<br>符（0 也是任意长度）<br>between and 关键字，表示大于等于第一个数，小于等于第二个数<br>select * from stuinfo where age between 18 and 20;where age &gt;=18 and age&lt;=20;<br>聚合函数<br>求和 sum，平均 avg，最大 max，最小 min，个数 count(<em>)使用聚合函数只有一行结果分组查询group by 写在 where 后面，order by 前面select \</em> from stuinfo group by age;只有聚合函数和被分组的列有意义使用 having 对分组结果进行条件查询，写在 group by 后面P43 count(*)和 count(列名)<br>count(列名)，如果列里面是 null 的，不计入总数</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>数据库有3中连接方式（MySQL有），其他数据库如（Oracle，SQL Server）<br>有 4 中包括全连接</p><h3 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h3><pre><code>SELECT 列名 1,列名 2… FROM 表 1，表 2 WHERE 条件</code></pre><p>另一种写法</p><pre><code>SELECT 列名 1,列名 2… FROM 表 1 INNER JOIN 表 2 ON 条件</code></pre><h3 id="2、左连接"><a href="#2、左连接" class="headerlink" title="2、左连接"></a>2、左连接</h3><pre><code>SELECT 列名 1,列名 2… FROM 表 1 LEFT JOIN 表 2 ON 条件</code></pre><h3 id="3、右连接"><a href="#3、右连接" class="headerlink" title="3、右连接"></a>3、右连接</h3><pre><code>SELECT 列名 1,列名 2… FROM 表 1 RIGHT JOIN 表 2 ON 条件</code></pre><h3 id="4、全连接"><a href="#4、全连接" class="headerlink" title="4、全连接"></a>4、全连接</h3><p>先左连接再右连接</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库基本案例</title>
    <link href="undefined2019/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A1%88%E4%BE%8B/"/>
    <url>2019/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Mysql的案例与基本操作："><a href="#Mysql的案例与基本操作：" class="headerlink" title="Mysql的案例与基本操作："></a>Mysql的案例与基本操作：</h3><p>步骤：</p><pre><code class="sql">1.create database schooldb;</code></pre><pre><code>2.use schooldb;</code></pre><pre><code>3.create table stuinfo(    number int auto_increment primary key,    name varchar(25) not null,    adress varchar(25),    score int,    rank int);</code></pre><pre><code>4.desc stuinfo;（显示表结构）</code></pre><pre><code>5.insert into stuinfo(number,name,adress,score,rank) values  (01,&#39;刘硕&#39;,&#39;镇平张林&#39;,98,1);</code></pre><pre><code>6.insert into stuinfo(name,adress,score,rank) values  (&#39;张&#39;,&#39;镇平晁陂&#39;,80,3),  (&#39;肖&#39;,&#39;镇平卢医&#39;,86,2);</code></pre><h3 id="一、关于数据库的基本操作"><a href="#一、关于数据库的基本操作" class="headerlink" title="一、关于数据库的基本操作"></a>一、关于数据库的基本操作</h3><p>创建数据库 -&gt;create database + 数据库名称<br>查看数据库 -&gt;show databases<br>删除数据库 -&gt;drop database + 数据库名称<br>使用数据库 -&gt;use + 数据库名称<br>查看创建数据库的详细信息-&gt;show create databases + 数据库名称<br>二、关于表的基本操作</p><p>显示数据库中的表：show tables<br>显示表的字段：desc + 表名称<br>删除表：drop table + 表名称<br>创建表：create table + 表名称（字段一 类型一，字段二 类型二）<br>查看创建表的详细信息：show create table + 表名称<br>三、修改表结构的操作</p><p>修改表字段的类型-&gt;alter table +表名称+ modify +字段+字段类型<br>添加表的字段-&gt; alter table + 表名称 + add +字段+字段类型<br>添加字段到指定位置-&gt;alter table +表名称 + add +字段+字段类型 +after 字段<br>删除表字段-&gt;alter table + 表名称 +drop +字段名称<br>修改指定字段名称-&gt;alter table +表名称 + change +原字段名称 +新字段名称 + 字段类型<br>四、基本操作–增、删、改、查</p><p>“增”—insert<br>（1） 对一行所有字段增加数据<br>语法：insert into +表名称 + values（值1，值2，……）<br>（2） 对指定字段增加数据<br>语法：insert into +表名称 +（字段1，字段2，……）+ values +（值1，值2，……）<br>“删”—delete<br>（1）删除表中指定数据<br>语法：delete from +表名称 +where条件表达式<br>（2）删除表中全部数据<br>语法：delete from +表名称<br>“改”—update<br>（1）修改表中现存数据<br>语法：update +表名称 +set 字段1=值1,字段2=值2 +where条件<br>PS：若不带where条件，则是对整表记录指定字段进行更新。<br>“查”—select<br>（1）select的简单查询<br>语法：select +字段1，字段2，字段3 +from +表名称 +where条件<br>PS：若查询全表信息则将所有字段名换为通配符 *。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web知识点总结</title>
    <link href="undefined2019/10/27/web%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/27/web%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点总结："><a href="#知识点总结：" class="headerlink" title="知识点总结："></a>知识点总结：</h3><p>1、HTML–超文本标记语言，以.html为扩展名。.htm网页文件<br>   浏览器–IE浏览器、FF火狐浏览器、Chrome谷歌浏览器、Safari苹果浏览器、O欧朋浏览器<br>   不同的浏览器，显示的效果不同，通常和浏览器或设备的宽度有关。<br>   什么是HTML？<br>   html语言–表名学习重点是代码部分。<br>   标记–生成网页的代码都是单独出现或成对出现的。<br>   例如： <b></b>–成对出现    <img>–单独出现<br>   超文本–网页中内容一般都是超链接，网页中各种元素都以文本的方式去描述。<br>   一首歌曲–D:/MP3/1.MP3，文本用路径把歌曲放在网页中执行<br>2、编写代码工具：HBuilder<br>   使用工具的方法：左侧项目管理器中—右键—新建web项目—项目名称（basic基本的、project项目、demo示例）—选择路径，尽量使用其他盘，不要放C盘或桌面—创建成功，相应的路径部分生成文件，css目录保存网页中的样式，img目录存放网页中的图片，js目录存放网页脚本，index.html文件是网页的入口文件，也叫索引文件，整个网页浏览依靠这个index.html文件。<br>  注意：站点名称不能是汉字，严格区分大小写，建议字母和数字组合。<br>3、网页的结构<br>   打开index.html文件，会发现有默认的网页结构。默认的结构是h5界面的。<br>   html发展历程：html4.0，用表格进行布局<br>                 xhtml1.0+css2.0，流行div+css布局<br>                 HTML5+css3.0，当下流行的<br>   完整开发模板调用：！+tab </p>   <!doctype html><p>文档声明–本文档是html网页的文档文件。<br>   网页的结构是html双标签包含网页中所有的内容。<br>   <html><br>   <head></head>–针对网页的定义<br>   <body></body>–针对网页中内容的显示<br>   </html><br>   在head标签中的标签：<br>    <meta charset="UTF-8">–meta元标记，定义网页<br>    charset字符集设置，utf-8和GB2312对应，utf-8中文和英文都支持  gb2312支持中文。<br>    <title>Document</title>标签控制网页标题栏的内容。<br>    body中内容的输入：<br>    不用写&lt;&gt;，直接写标签名称+tab让软件提示。<br>    注意：网页中的回车和空格都不影响网页效果，也就是说网页中回车和空格无效。</p><p>回顾：<br>    1、空格和换行在网页中不生效，进而说明编辑HTML的时候，输入多余的空格和回车不影响网页显示效果的，如果要强制使用空格用&nbsp;强制换行<br>标签。<br>     注意：br标签是单标签，所以/前要加空格。<br>   2、补充内容：<br>     meta元标签可以定义的：<br>   <meta name="viewport" content="width=device-width, initial-scale=1.0"><br>    设定视图的自适应宽度。网页中的内容在不同设备里显示宽度不一致。<br>        <meta name="Keywords" content="网页关键字"><br>    <meta name="Description" content="网页的描述"><br>   3、使用标签的注意事项：无论何种标签，标签必须使用小写字母表示，属性必须使用小写字母，标点符号必须使用不在输入法情况下输入效果。标签必须正确的嵌套。<br>      使用单标签：注意/前加空格。<br>      使用双标签：先写标签，再往标签内部插入其他标签或内容。<br>      网页中所有的内容都必须被标签包含，这样才能控制内容的修饰。加标签方便控制。<br>   总结：在HBuilder中，代码颜色有重要参考意义。标签都是浅蓝色，属性都是橙色，属性中的属性对显示绿色。<br>  4、为标签添加属性方法，在首标签中添加空格，激活软件的提示功能，进而进行选择属性的插入。<br>     style属性：可以引出相关的属性对，一组属性对用;表示结束。<br>     align属性：可以控制水平对齐方式。<br>  5、注释：针对代码进行解释，在网页中不显示。先写注释内容，然后鼠标拖拽选择注释内容，ctrl+/即可。<br>  6、自动跳转网页设置：<br>    <meta http-equiv="refresh" content="5;url=http://www.baidu.com"> 自动跳转<br>    5;url=<a href="http://www.baidu.com是content中的值。" target="_blank" rel="noopener">http://www.baidu.com是content中的值。</a><br>  7、hn的标题：n表示1-6，1字体最大，6字体最小。外联元素。外联元素占满了一行。<br>  8、p标签表示段落标记，外联元素。<br>  总结：所有的标签都分为不会自动换行的内联元素和会自动换行的外联元素，外联元素也叫块级元素。<br>        外联元素会自动换行，可以添加对齐的属性，所以可以用来布局。<br>        内联元素不会自动换行，不可以添加对齐的属性，无法布局，特点是只能进行修饰。<br>        外联元素–h标题标签和p段落标签<br>        内联元素–b加粗、u下划线、i倾斜、s删除、上标sup和下标sub<br>    如何验证陌生标签是内联和外联元素？<br>  9、相对路径和绝对路径<br>     绝对路径–可以是根目录开头的路径，如d:/abc/1.jpg<br>             –也可以是网上的网址路径，如<a href="http://www.baidu.com/img/1.jpg" target="_blank" rel="noopener">http://www.baidu.com/img/1.jpg</a><br>     相对路径–找文件之间的相对关系，平级文件直接写文件名。上一级文件用../表示。<br>  10、a标签–内联元素超链接标记，自带字体和蓝色，有下划线效果，必须添加href属性，否则不会有超链接的效果，如href没有具体的地址，用#表示空连接。target属性窗口的打开方式，_blank新窗口打开，_self本窗口内跳转。<br>     注意：a标签中的href和img标签中的src有区别的：<br>           href是从当前文件连接过去。<br>           src是把远处的文件拿过来展示。<br>  11、图片标签img标签，src表示图片的路径，站点中是相对路径。alt图片的描述，title属性是图片的提示信息，鼠标放在图片上的提示。切记，网页中图片不要用宽度width和高度height属性去控制图片的尺寸，网页应用图片之前要事先修改好图片的大小。图片是内联元素。<br>  12、图片的三种格式区别： gif动图–也可以用来表示背景透明的图片，常用来表示颜色单一的logo图。<br>                           jpg图–网页常用的图片，放大后会失真，变模糊。<br>                           png图–对分辨率要求较高，文件占位比较大。<br>  13、列表–ol有序列表，ul无序列表，dl自定义列表–列表都是外联元素。<br>       ol有序列表–ol中属性可以用type设定有序列表的样式，1、a、A、i、I表示。用start表示从第几个列表符号开始。<br>       ul列表中可以使用属性type，circle是空心点，disc实心点，square是矩形点。<br>       dl表示自定义列表，dt表示列表名称，dd对于名称的解释。<br>  14、table表格-table表示表格，th表示列首（一列中第一个单元格），tr表示一行，td表示一个单元格。<br>      table中的属性，border表格的边框，cellspacing表示表格的单元格之间的距离，cellpadding表示内容到单元格之间的内间距，bordercolor边框颜色，bgcolor表格的背景颜色，width宽度，height高度。<br>      行占位符和列占位符的用法：操作合并单元格的方法<br>      行占位符rowspan–占行成列的效果。<br>      列占位符colspan–占列成行的效果。<br>      切记一点：使用合并单元格，要先判断占行还是占列，然后添加占位符，删除对应的占位符。<br>  15、在表格中的thead标签，只可以用对其方式控制水平位置的变化，而不能进行样式的修饰。<br>      在表格中的tbody标签，使用方法遵循表格中tr和td内容显示，使用属性也都生效。<br>      在表格中的tfoot表示页脚，页脚中也可以用tr和td去显示内容。可以使用对齐方式。<br>  16、表单form标签，表单是搜集数据的，是外联元素，属性action表示将表单搜集的输入的内容传递到的目的地路径。<br>      属性method表示，把搜集的数据用何种方式传递到action定义的地址中去。<br>      在表单中，有三个主要的标签：input输入框   select选择下拉框  textarea文本域<br>      注意：这三个标签都要被form标签去包含。<br>      在input中最重要的是type属性，type属性表明是何种表单元素。<br>      <label for="tiger">用户名：</label><br>      <input type="text" value="请输入您的账号" id="tiger" maxlength="5"><br>解释：type=”text”表明这是一个可以输入文本的输入框，value文本框中默认的内容，id给文本框加上id，maxlength表示这个文本框最大输入几个字符。因为html中所有内容要被包含，所以添加label标签包含用户名，label中属性for的值对应相关表单的id值，只能对应id，不能对应别的参数，id必须使用英文，不得使用汉字。<br>      <input type="password" id="pwd" value="******"><br>      密码的type属性是password！<br><label for="man">男：</label><br><input type="radio" id="man"><br>单选的type值是radio，为实现单选的效果，必须为input添加name属性。name值一致，才能出现单选的效果。<br>     <input type="checkbox"><br>多选框的type值为checkbox，表示可以多个选择。<br>     <input type="file">type为file是上传文件的按钮。<br>    <input type="submit" value="提交">type为submit是提交按钮，点击提交按钮，会把form搜集的文件通过method定义的方式传递到action定义的地址去。<br>     <input type="reset" value="提交">type为reset重置，会把输入的内容清空。<br>    <input type="button" value="提交">type为button按钮，单纯点击，没有效果。<br>    按钮也可以直接作为标签使用–如：<button>按钮</button><br>17、表单中的下拉菜单select标签，包含的是option标签，option的属性有selected=”selected”选择默认的选项。<br>18、表单中的textarea表示文本域，rows表示文本域的高度，cols表示文本域的宽度。<br>总结：表单中的form是外联元素，而form中所有的内容都是内联元素。换行要用br强制换行。<br>表单的高级应用：<br> 表单中在HTML5中新增的input中type的属性：<br>   1、email，强制定义网页中的必须输入邮箱。如：<input type="email"><br>   2、number，强制定义输入的是数字，数字可以增加或减少。如：<input type="number"><br><br>   3、输入日期格式，year年，month月，day日，week周，time时间，datetime日期加时间格式：<br>      如：<input type="year"><br>   4、表示控制范围：<input type="range">，min属性表示最小，max表示最大<br>   5、只读的表单：<input type="text" value="张三很坏" readonly="readonly"><br> 表单中新增的属性：<br>    placeholder属性，当输入内容，默认的内容就不显示。如：<input type="text" placeholder="点我你看看我"><br>    required属性，设置表单中不能为空，必须输入内容。如：<input type="text" required="required" value="这个不能为空啊"><br>    6、label标签用来将内容和表单中的input进行绑定，利用label中for属性的值要和input中的id值对应，这样点击label的内容，就可以<br>       把光标设置在input的文本框中。<br>19、form中的fieldset标签包含legend标签，显示效果是美化的表单，线在文字中间，包含form中所有的内容。</p><form action="#" method="post">       <fieldset id>           <legend>注册界面</legend>           <label for="name">用户名：</label>           <input type="text" id="name" value="请输入内容">       </fieldset>    </form>       网页中的多媒体信息和新增HTML标签：   1、HTML5新增标签：这些标签都是放在body中的内容部分。      header--这个标签表示网页的头部信息，头部一般放网页的logo标志和其他相关信息。      nav导航标签--一般放网页中的导航信息。      article标签--表示网页中主要的内容。      section定义内容中的节，自然段。      aside--表示和内容相关的内容。如左侧是站内导航，右侧是关于导航的详细信息。      footer--表示网页的底部，一般放网页中的版权和警告信息。   2、关于网页中的多媒体信息：      bgsound标签控制网页背景音乐。<bgsound src="video/1.mp3"></bgsound>      audio标签网页中可见的mp3的播放：      <audio autoplay="autoplay" controls="controls">             <source src="video/1.mp3">         </audio>     autoplay自动播放，controls显示播放控件。   3、关于网页中的视频播放：      object标签、video标签      <video autoplay="autoplay" controls="controls">             <source src="video/1.mp4">         </video>     object标签： <object class id="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,19,0" width="500" height="440">  <param name="movie" value="flvplayer.swf">  <param name="quality" value="high">  <param name="allowFullScreen" value="true">  <param name="FlashVars" value="vcastr_file=video/abc.flv&LogoText=www.iloveyou.com&BufferTime=3&IsAutoPlay=0">  <embed src="flvplayer.swf" allowfullscreen="true" flashvars="vcastr_file=video/abc.flv&LogoText=www.iloveyou.com&IsAutoPlay=0" quality="high" pluginspage="http://www.macromedia.com/go/getflashplayer" type="application/x-shockwave-flash" width="500" height="440"></object>               <video width="600" height="300" controls src="birds.mp4"></video>        <hr>        <video width="200" height="100" controls>            <source src="birds.mp4" type="video/mp4">        </video>   4、在网页中嵌套其他网页：       <iframe src="http://www.baidu.com" width height></iframe><p>网页中的CSS样式：对于网页内容进行修饰。<br>CSS文件叫层叠样式表，用来修饰网页中内容的样式，层叠表示修饰样式是多层存在的。<br>   a、CSS的文件扩展名是.css，在站点的css目录中建立层叠样式表的文件，一般用css.css或者style.css命名。<br>CSS样式可以修饰的内容是：内联元素标签和外联元素的标签。<br>     内联元素的特征：不会换行，重点在修饰，用css修饰内联元素自身之外的属性。<br>     外联元素的特征：自动换行，重点在布局，用css修饰外联元素进行布局时的宽度高度和位置等信息。<br>  总结：所有的HTML标签分为单标签和双标签，这两种标签都能用css修饰。<br>        所有的html标签分为内联元素和外联元素（块级元素），分别用css修饰各种的特点。<br>   b、使用css的方法，在css目录简历style.css的文件。然后再index.html入口文件的head部分，添加link的标签，link中的href属性来关联css的样式表文件。<br>      <link rel="stylesheet" type="text/css" href="css/style.css"><br>      rel属性表示样式的标签，tyle属性定义css的文本，href定义连接外部文件的路径。<br>   测试是否连接成功：<br>     在style.css中测试body{ background-color: blue;}，浏览器如果显示蓝色，表示连接成功。<br>     其中body叫css的选择符，在{ }中的background-color表示body的背景颜色，blue设置body的背景颜色为蓝色。<br>  注意：使用css时，第一行切记添加定义css的字符集。@charset “utf-8”;<br>上节课回顾：<br>   1、网页引用CSS文件的方法：<br>      a、link关联法，link关联法是网页文件index.html和style.css进行关联，也是唯一符合SEO规范的CSS引用方法。<br>      b、在网页文件index.html中的head标签中写入style的双标签，标签中写具体的css样式。<br>        例如：<style type="text/css"><br>        body{ background-color: green;}<br>           </style><br>      c、在网页文件index.html中的head标签中写入style的双标签，标签中写具体的css的外部引用文件。<br>        例如：<style type="text/css"></p><pre><code>       &lt;/style&gt;    注意：这种方法只能引入css的文件。  d、在网页的body中，双标签在首标签中插入style的属性，引出css的属性和值。    例如：&lt;h1 style=&quot;color: red; font-size: 160px;&quot;&gt;我是一个标题&lt;/h1&gt;   注意：每一个css属性写完，都要用分号结束。</code></pre><p>总结：使用CSS层叠样式表，可是实现网页的结构和样式的分离，方便我们对于网站进行维护。也就是说index.html中专门写html代码，在style.css中只写css样式，如果对于样式进行维护，直接打开style文件即可，无需考虑index.html的代码。<br>   2、css中的选择符：<br>      选择符{属性1：值1；属性2：值2；…}<br>   3、常用的选择符：<br>      a、类型选择符、元素选择符、标签选择符<br>      例如：在index.html中：<h1>我是内容</h1><br>            在style.css中：h1{color:red}<br>      b、id选择符，给html的标签设置id属性，在css中，用#id名称进行引用。<br>      例如：在index.html中：<h1 id=“tiger”>我是内容</h1><br>            在style.css中：#tiger{color:red}<br>      注意：id选择符具有唯一性，所以id的名称只能定义一次。id并不是只能使用一次。<br>      例如：在index.html中：<br>          <h1 id="tiger">我是另外一个h1</h1><br>      <p id="tiger">我是段落</p><br>            在style.css中：#tiger{color:red}<br>      c、class选择符，类选择符，类选择符可以定义一次，可以多次使用。在css中用.加类名引用。<br>          例如：在index.html中：<br>          <h1 class="tiger">我是另外一个h1</h1><br>      <p class="tiger">我是段落</p><br>             在style.css中：.tiger{color:red}<br>      注意：class选择符和id选择符的区别：class可以定义多个，id只能定义一个。<br>        案例：  在html中的代码：<br>                 <h1 class="tiger apple small">我是另外一个h1</h1><br>             <p id="banana daxiao">我是id的段落</p><br>             在css中：<br>                 .tiger{ font-size: 30px;}<br>             .apple{ color: red;}<br>             .small{ text-decoration: underline;}<br>             #banana{ color: green;}<br>             #daxiao{font-size: 70px;}<br>        d、交集选择符，由类型选择符和id选择符或类型选择符和class选择符组合使用生成的选择符。<br>         例如：在index.html中：<br>          <h1 class="tiger">我是另外一个h1</h1><br>      <p class="tiger">我是段落</p><br>             在style.css中：.tiger{color:red;}<br>                            h1.tiger{属性：值}<br>                             p.tiger{属性：值}<br>           注意交集选择符p.tiger{属性：值}一定类型选择符和类名引用相连，不能有空格。<br>        e、并集选择符–表示平级的选择符之间的关系。<br>           在html中：   <h1>我是另外一个h1</h1><br>                    <p>我是id的段落</p><br>           在css文件中： h1,p{color: red;}   —表示h1的标签和p的标签都遵循这个属性。<br>        f、混合选择符，交集选择符，类型选择符，id选择符，class选择符，同时使用。<br>           在css中：h1.apple,h5#banana{}–h1的apple类，和h5的id为bananan的都遵循此属性。<br>        g、包含选择符，也叫后代选择符—表示包含关系的选择符<br>            在html中： <h1><p>hello</p></h1><br>            在css中：h1 p{color: red;}–表示h1中包含的p标签的属性。<br>        h、*通配符–表示所有的类型选择符都遵循此属性。<br>           *{属性：值}<br>  案例：在index.html中：<br>         <h1>八仙过海</h1><br>       <p><a href="">八仙</a>那天有空，想要<a href="#" class="yanse">过海</a>，<br>           于是一个一个的拿出<a href="#">法宝</a>，<br>           就<a href="#" class="yanse ziti">过海</a>了</p><br>        在CSS文件中：<br>         *{ font-size: 35px;}<br>        h1{ color: red;}<br>         p{ font-size: 18px;}<br>       p a{ color: blueviolet;}<br>     p a.yanse{ color: darkkhaki; text-decoration: none;}<br>    p a.ziti{font-style: italic; font-weight: bold;}</p><p>在CSS中的选择符的优先级：当选择符定义同一个标签的元素，鉴别以哪种选择符的属性为准。<br>   id选择符&gt;class选择符&gt;类型选择符&gt;通配符*<br>  优先级中行内样式优先级最高！<br>  注意：在选择符中，行内样式定义的CSS距离内容最近，所以优先级最高，也就是县官不如现管！<br>        因为ID具有唯一性，而class可以定义多个，所以id大于class选择符。<br>        class可以单独定义到具体的html标签，所以针对性比类型选择符强，所以优先级比类型选择符高。<br>        <em>代表全局，范围太广泛，所以优先级是最低的。当我们使用样式，针对大多数的样式，可以使用</em><br>        进行定义，个别的样式单独存在的一种样式用id定义，凡是出现多次相同样式用class定义。<br>        当用<em>进行定义了属性，其他选择符定义的属性和</em>相同，就会把*通配符定义的属性冲突掉。<br>  案例：在index.html中：<br>          <h1>实训室教师使用管理规定</h1><br>      <ol><br>          <li class="yanse">不准吃饭1不准吃饭1不准吃饭1不准吃饭1</li><br>          <li>不准吃饭2不准吃饭2不准吃饭2不准吃饭2</li><br>          <li class="yanse">不准吃饭3不准吃饭不准吃饭不准吃饭</li><br>          <li>不准吃饭4不准吃饭不准吃饭不准吃饭</li><br>          <li class="yanse">不准吃饭5不准吃饭不准吃饭不准吃饭</li><br>          <li>不准吃饭6不<b class="italic">准吃</b>饭不准吃饭</li><br>          <li>不准吃饭7不准吃饭不准吃饭不准吃饭</li><br>          <li id="tiger">不准吃饭8不准吃饭不准吃饭不准吃饭</li><br>          <li>不准吃饭9不准吃饭<a href="#">不准吃饭</a>不准吃饭</li><br>          <li class="qingxie">不准吃饭10不准吃饭不准吃饭不准吃饭</li><br>      </ol><br>​       在css中的属性：<br>​          *{ color: blue; font-size: 28px;}<br>​      h1{font-size: 50px; font-family: “微软雅黑”;}<br>​      ol li.yanse{ color: red;}<br>​      ol li#tiger{ font-weight: bold;}<br>​      ol li.qingxie{ font-style: italic;}<br>​      ol li b{text-decoration: underline;}<br>​      ol li b.italic,ol li a{ color: darkgoldenrod;}<br>​    注意：font-family设置字体<br>​          font-size字体大小<br>​          font-weight: bold;字体加粗<br>​          font-style: italic;倾斜效果<br>​          text-decoration: underline;添加和删除下划线  underline是添加下划线，none是取消下划线</p><p> 上节课的回顾：CSS的引用四种方法，选择符的使用方法，常用的选择符，选择符的优先级</p><p>   关于DIV+CSS布局：<br>     内联元素修饰，外联元素布局。如果要修饰内联元素标签，就要使用b标签或者u标签，修饰不换行的内容，就要用内联标签，但内联标签不干净，自带有修饰效果，所以我们需要一个干净的没有任何自带修饰效果的内联元素标签，w3c组织提出干净的内联标签这个标签是span标签。<br>     与之相对象和匹配的，提出了一个干净的会自动换行的外联元素的标签，叫div标签。<br>     span内联+div的外联标签都是干净的标签，div专门用于布局，span专门用于修饰。<br>     因为网页中的每一块内容都是独立存在的，每一块都是布局，所以针对id选择符的特点，我们在div标签中如果要修饰div的css属性，用id选择符。修饰内联的span用class选择符。因为类可以有多个，又专门进行样式修饰使用的，所以span中使用class选择符。<br>     授课思路：先讲解内联元素的CSS属性有哪些？再讲解修饰外联元素的属性有哪些？<br>  内联元素的属性：<br>   a、字体font：<br>   font-family设置字体   font-size字体大小   font-weight: bold;字体加粗    font-style: italic;倾斜效果  color字体颜色<br>   b、文本text：<br>   text-align文本对齐方式，左中右   text-decoration:文本的下划线属性  text-indent首行缩进<br>   c、锚伪类，控制鼠标经过，鼠标选中，鼠标访问过后的效果<br>                a:link{color:red}–默认样式<br>                a:hover{ color: red;}—-鼠标经过<br>        a:active{ color: green;}–鼠标选定，手点击别松<br>        a:visited{color: yellow; }–鼠标点一下<br>    在网页使用锚伪类时，顺序不能改变，分别就是鼠标经过，鼠标选定，鼠标点击。<br>修饰外联元素的CSS属性：外联元素是一块，所以也叫块级元素，所以就有了网页中的盒子模型。<br>     盒子模型是指网页中的内容，盒子模型–border边框、content内容、内间距padding、margin外间距。所有的外联元素和内联元素都可以理解为一个盒子的存在。盒子模型中有宽度、高度、边框线、内间距、外间距<br>    a、width宽度，宽度有固定宽度和自适应宽度auto两种。<br>       width：200px;固定宽度，width：100%自适应宽度。<br>    inherit(继承)宽度，当父级的盒子指定固定宽度，而包含的盒子不指定宽度，包含的盒子会继承父级盒子的宽度。由此可见，宽度可以继承，高度可以被内容撑起。<br>    注意：只有外联元素才有宽（设定宽度网页效果会生效）。内联元素也有宽高，但是是随着内容而变化的宽高，也就是指定内联元素的宽高是不会有效果的。<br>    b、height高度，高度有固定高和内容撑起的高两种。<br>       height：200px；固定的高度。高度的属性不写，真实的高度会被内容撑起。<br>    注意：宽度的特征是会继承，高度的特征是不会继承父级元素的高，但会被内容撑起来。<br>    内容可能超过父级元素标签的宽高，所以我们用overflow控制内容溢出的属性。<br>    overflow的属性一般在父级元素标签中使用：<br>    overflow: hidden;当子级的标签超过父级标签，超出的部分隐藏掉。<br>    overflow: auto;超出部分会显示滚动条，如果不超出，就不显示滚动条。<br>    overflow: scroll;无论是否超出，都强制显示滚动条。<br>   总结：当使用宽度和高度的属性时，尽量写父级元素大盒子的宽度，别写高度，里面的小盒子只写高度，别写宽度。<br>          当宽度高度都是固定的高度，要使用overflow的属性。<br>    c、边框线border，可以同时定义四条线，可以定义单独一条线，一般我们采用简写的方式表示边框：<br>       border: dashed 1px red;<br>       注意：线的类型dashed虚线   dotted点线  solid实线  double双线（线的粗细不能低于1px）<br>    d、padding内间距，表示边框到内容之间的距离。设定盒子的内间距，会撑大盒子。<br>       内间距可以定义四个方向：当按照顺时针的方式进行每个padding的设定，盒子会被撑大相应的尺寸，和内容的间距，是padding-top和padding-left是真实的间距。当定义了padding-top间距，padding-bottom值失效（虽然值失效，这里失效是内容和边框间距失效，但撑大盒子的值并未失效），依次类推，定义padding-left，padding-right的值失效，但撑大效果并未失效。<br>       padding的简写效果：<br>       padding：10px—内间距四个方向都是10px间距<br>       padding：10px 20px；–内间距上下10px，左右20px间距。<br>       padding：10px 20px 30px；–内间距上10px，左右20px，下30px；<br>       padding：10px 20px 30px 40px–上10px，右20px，下30px，左40px（顺时针方向指定）<br>    固定宽高的盒子尺寸=宽度+内间距+border线<br>   总结：调整内容在大盒子中的位置，可以采用内间距padding，但内间距会撑大盒子，所以一定有属性也可以改变内容的间距，且不撑大盒子。这就是内容的外间距。<br>    继承大盒子的宽度的小盒子设定内间距为什么不受内间距撑大盒子的影响？<br>     当继承的宽度（不是固定设定的宽度）设定内间距不会撑大盒子。<br>    e、外间距margin，表示内容到边框的间距。简写的方式和内间距一样，也是顺时针进行设定。<br> padding的简写效果：<br>       margin：10px—内间距四个方向都是10px间距<br>       margin：10px 20px；–内间距上下10px，左右20px间距。<br>       margin：10px 20px 30px；–内间距上10px，左右20px，下30px；<br>       margin：10px 20px 30px 40px–上10px，右20px，下30px，左40px（顺时针方向指定）<br>    注意：外联元素和内联元素都可以使用内间距和外间距，但生效的位置不一样。<br>          外联元素进行内间距和外间距生效的是四个方向。<br>          内联元素的内间距生效的距离是左右和下，外间距生效的范围是水平的左右。<br>          利用外间距margin：0 auto；表示一个盒子的居中，但要注意，没有固定宽度的盒子是无法居中的。<br>   通常的盒子模型指的是内联元素还是外联元素？<br>    盒子模型–border边框，content内容，内间距padding，外间距margin<br>    内联元素也可以理解为盒子模型，因为都有边框内容和间距，但要注意，内联元素宽和高都是依靠内容撑起的，内间距依然撑大内联元素的盒子，外间距可以控制内联元素的外间距，但生效方式只有水平横向的位置。<br>    课堂案例操作习惯使用div外联元素进行演示的原因是在div表示盒子模型中的每个属性设定都有效果，所以用div验证盒子模型。用div宽度和高度都可以设定，但内联宽高无法设定。<br>    f、浮动float–盒子脱离了body文档流进行水平方向的移动。<br>       float：left左浮动     float：right右浮动     float：none不浮动<br>       清除浮动clear：清除浮动并不是设定盒子不再浮动回到body层，而是清除前面盒子布局对于后面盒子布局的影响，可以操作浮动层的内容换行。<br>      <div id="tiger"></div>    #tiger{ clear: both;}<br>​    g、定位position–盒子脱离body的文档流，进行二维坐标的定位。二维坐标就是top上，下bottom，左left，右right，当使用定位时，上下二维坐标取一个值，左右二维坐标取一个值，就能定位到一个具体的位置。<br>​      相对定位relative：相对盒子当前的位置进行移动，原先位置内容消失，脱离文档流。<br>#box{width: 200px;height: 200px; background: red;position: relative;top: 10px;left: 10px;}<br>​        a:hover{position: relative;top: 1px; left: 1px;}<br>    <div id="box"></div><br>​    <a href="#">搜狐</a><br>​      绝对定位absolute：相对body的边框进行移动，原先位置内容取消，脱离文档流。<br>​      注意：当大盒子定义了相对定位，小盒子定义绝对定位，小盒子的绝对定位不再参照body，而是参照大盒子进行移动。<br>​      固定定位fixed：始终参照body的位置进行定位。<br>​     使用定位时，如果定位的盒子发生了重叠，使用z-index来表示盒子层叠的优先级。<br> #box{width: 300px;height: 300px; background: red; position: relative; top: 10px; left: 10px;z-index: 1;}<br>#son{ width: 200px; height: 200px; background: blue; position: relative; top: -80px; left: 80px; z-index:0 ;}<br>#small{width: 100px;height: 100px; background: green;  position: relative; top: -250px; left: 250px;z-index: -1;}<br>           <div id="box"></div><br>       <div id="son"></div><br>       <div id="small"></div><br>​     h、visibility元素是否可见: hidden隐藏;visibility: hidden;表示盒子被隐藏但会有占位的效果。<br>​     j、display转换：实现内联元素和外联元素的相互转换。<br>​        display: inline;外联转内联<br>​        display: block；内联转外联<br>​        display：inline-block；行内块级元素，在一行显示，但可以定义宽高。<br>   网页中的列表、背景和控制图片的CSS属性：<br>   列表分为三类–有序列表ol   无序列表ul  自定义列表dl<br>​           注意：分清楚有序列表和无序列表的区别？使用列表要注意列表是有默认的内间距的。<br>​        默认有间距的是body的标签、h的标题标记、ul列表都有默认间距。无序列表中，列表符号和列表的内容默认不是一体的<br>​      列表可以用来制作网页中的新闻列表和菜单栏：使用列表时用包含选择符，先写列表的框架，再写列表的CSS选择符。<br>​      ul是外联元素，可以定义宽度，高度，实现居中对齐。<br>​      li是ul标签的子级元素，会继承ul的宽度，但注意ul有默认的内左侧间距，所以li是ul设定的宽度。可以利用通配符*清除默认的间距。 定义li的color颜色属性，列表符号的颜色会变化。<br>​      list-style列表符号的样式: square矩形点;none清除列表符号。<br>​      list-style-image: url(img/list.gif)列表图片的设定。<br>​      list-style-position: inside;设定符号在li里面，和li是一体的。<br>​      line-height设定行高，设定的是每行的高度。<br>   网页中的背景background：背景颜色，背景图片，背景图片是否重复，背景图片坐标，背景图片锁定。<br>   background-color: #ccc;背景颜色<br>   background-image: url(img/abb.jpg);背景图片，默认平铺效果<br>   background-repeat:no-repeat;背景图片重复<br>   background-position:1600px 30px;背景图片定位<br>   background-attachment: fixed;  背景图片锁定<br>   背景的使用一定要写简写的方式：<br>   background：#ccc url(路径) reapeat left left fixed；注意：背景图片的优先级高于背景颜色。<br>   背景填充法和CSS取图：<br>​     background: url(img/timg.jpg) no-repeat -441px -303px;<br>   网页中的图片img和表单form：<br>  a、网页中的图片多使用class选择符去引用，网页中通常能使用的属性是src属性和alt属性（图片信息的描述）<br>  b、img–src属性   link–href属性   a–href属性。切记不要使用width和height属性修饰图片的尺寸。<br>   网页中的form表单：表单form由三部分构成-input输入、select下拉菜单、textarea文本域，表单是外联元素，但里面的input、select、textarea都是内联元素不换行，所以使用表单时必须写form的标签，否则无法控制文本框input等内容的布局位置。<br>  c、行高的属性line-height：一行的高度，通过使用行高可以控制内容的行间距。如果一个盒子中有高度，而行高和高度一致，那么盒子中的文本内容会在盒子垂直居中的位置。也就说，文本的垂直居中使用vertical-align是不生效的，是通过行高进行设定的。<br>​     注意：内联元素不能设定高度，但是可以设定行高。<br>​           现在讲到的知识点可以使用vertical-align的元素有哪些？图片，表单（特殊的内联元素）。<br>​           特殊的内联元素特点–横在排列，在一行显示不换行，但是却可以控制元素的宽高。<br>  d、手型工具cursor:  默认手型 pointer; 帮助help；<br>  e、网页中的导航菜单：使用ul制作。利用li把列表的点清除掉，转换a标签变成块级元素，设定宽高，设定水平和垂直对齐方式，设置每个a标签的外间距即可。</p></style></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>