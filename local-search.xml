<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>web知识点总结</title>
    <link href="undefined2019/10/30/web%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/30/web%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="知识点总结："><a href="#知识点总结：" class="headerlink" title="知识点总结："></a>知识点总结：</h3><p>1、HTML–超文本标记语言，以.html为扩展名。.htm网页文件<br>   浏览器–IE浏览器、FF火狐浏览器、Chrome谷歌浏览器、Safari苹果浏览器、O欧朋浏览器<br>   不同的浏览器，显示的效果不同，通常和浏览器或设备的宽度有关。<br>   什么是HTML？<br>   html语言–表名学习重点是代码部分。<br>   标记–生成网页的代码都是单独出现或成对出现的。<br>   例如： <b></b>–成对出现    <img>–单独出现<br>   超文本–网页中内容一般都是超链接，网页中各种元素都以文本的方式去描述。<br>   一首歌曲–D:/MP3/1.MP3，文本用路径把歌曲放在网页中执行<br>2、编写代码工具：HBuilder<br>   使用工具的方法：左侧项目管理器中—右键—新建web项目—项目名称（basic基本的、project项目、demo示例）—选择路径，尽量使用其他盘，不要放C盘或桌面—创建成功，相应的路径部分生成文件，css目录保存网页中的样式，img目录存放网页中的图片，js目录存放网页脚本，index.html文件是网页的入口文件，也叫索引文件，整个网页浏览依靠这个index.html文件。<br>  注意：站点名称不能是汉字，严格区分大小写，建议字母和数字组合。<br>3、网页的结构<br>   打开index.html文件，会发现有默认的网页结构。默认的结构是h5界面的。<br>   html发展历程：html4.0，用表格进行布局<br>                 xhtml1.0+css2.0，流行div+css布局<br>                 HTML5+css3.0，当下流行的<br>   完整开发模板调用：！+tab </p>   <!doctype html><p>文档声明–本文档是html网页的文档文件。<br>   网页的结构是html双标签包含网页中所有的内容。<br>   <html><br>   <head></head>–针对网页的定义<br>   <body></body>–针对网页中内容的显示<br>   </html><br>   在head标签中的标签：<br>    <meta charset="UTF-8">–meta元标记，定义网页<br>    charset字符集设置，utf-8和GB2312对应，utf-8中文和英文都支持  gb2312支持中文。<br>    <title>Document</title>标签控制网页标题栏的内容。<br>    body中内容的输入：<br>    不用写&lt;&gt;，直接写标签名称+tab让软件提示。<br>    注意：网页中的回车和空格都不影响网页效果，也就是说网页中回车和空格无效。</p><p>回顾：<br>    1、空格和换行在网页中不生效，进而说明编辑HTML的时候，输入多余的空格和回车不影响网页显示效果的，如果要强制使用空格用&nbsp;强制换行<br>标签。<br>     注意：br标签是单标签，所以/前要加空格。<br>   2、补充内容：<br>     meta元标签可以定义的：<br>   <meta name="viewport" content="width=device-width, initial-scale=1.0"><br>    设定视图的自适应宽度。网页中的内容在不同设备里显示宽度不一致。<br>        <meta name="Keywords" content="网页关键字"><br>    <meta name="Description" content="网页的描述"><br>   3、使用标签的注意事项：无论何种标签，标签必须使用小写字母表示，属性必须使用小写字母，标点符号必须使用不在输入法情况下输入效果。标签必须正确的嵌套。<br>      使用单标签：注意/前加空格。<br>      使用双标签：先写标签，再往标签内部插入其他标签或内容。<br>      网页中所有的内容都必须被标签包含，这样才能控制内容的修饰。加标签方便控制。<br>   总结：在HBuilder中，代码颜色有重要参考意义。标签都是浅蓝色，属性都是橙色，属性中的属性对显示绿色。<br>  4、为标签添加属性方法，在首标签中添加空格，激活软件的提示功能，进而进行选择属性的插入。<br>     style属性：可以引出相关的属性对，一组属性对用;表示结束。<br>     align属性：可以控制水平对齐方式。<br>  5、注释：针对代码进行解释，在网页中不显示。先写注释内容，然后鼠标拖拽选择注释内容，ctrl+/即可。<br>  6、自动跳转网页设置：<br>    <meta http-equiv="refresh" content="5;url=http://www.baidu.com"> 自动跳转<br>    5;url=<a href="http://www.baidu.com是content中的值。" target="_blank" rel="noopener">http://www.baidu.com是content中的值。</a><br>  7、hn的标题：n表示1-6，1字体最大，6字体最小。外联元素。外联元素占满了一行。<br>  8、p标签表示段落标记，外联元素。<br>  总结：所有的标签都分为不会自动换行的内联元素和会自动换行的外联元素，外联元素也叫块级元素。<br>        外联元素会自动换行，可以添加对齐的属性，所以可以用来布局。<br>        内联元素不会自动换行，不可以添加对齐的属性，无法布局，特点是只能进行修饰。<br>        外联元素–h标题标签和p段落标签<br>        内联元素–b加粗、u下划线、i倾斜、s删除、上标sup和下标sub<br>    如何验证陌生标签是内联和外联元素？<br>  9、相对路径和绝对路径<br>     绝对路径–可以是根目录开头的路径，如d:/abc/1.jpg<br>             –也可以是网上的网址路径，如<a href="http://www.baidu.com/img/1.jpg" target="_blank" rel="noopener">http://www.baidu.com/img/1.jpg</a><br>     相对路径–找文件之间的相对关系，平级文件直接写文件名。上一级文件用../表示。<br>  10、a标签–内联元素超链接标记，自带字体和蓝色，有下划线效果，必须添加href属性，否则不会有超链接的效果，如href没有具体的地址，用#表示空连接。target属性窗口的打开方式，_blank新窗口打开，_self本窗口内跳转。<br>     注意：a标签中的href和img标签中的src有区别的：<br>           href是从当前文件连接过去。<br>           src是把远处的文件拿过来展示。<br>  11、图片标签img标签，src表示图片的路径，站点中是相对路径。alt图片的描述，title属性是图片的提示信息，鼠标放在图片上的提示。切记，网页中图片不要用宽度width和高度height属性去控制图片的尺寸，网页应用图片之前要事先修改好图片的大小。图片是内联元素。<br>  12、图片的三种格式区别： gif动图–也可以用来表示背景透明的图片，常用来表示颜色单一的logo图。<br>                           jpg图–网页常用的图片，放大后会失真，变模糊。<br>                           png图–对分辨率要求较高，文件占位比较大。<br>  13、列表–ol有序列表，ul无序列表，dl自定义列表–列表都是外联元素。<br>       ol有序列表–ol中属性可以用type设定有序列表的样式，1、a、A、i、I表示。用start表示从第几个列表符号开始。<br>       ul列表中可以使用属性type，circle是空心点，disc实心点，square是矩形点。<br>       dl表示自定义列表，dt表示列表名称，dd对于名称的解释。<br>  14、table表格-table表示表格，th表示列首（一列中第一个单元格），tr表示一行，td表示一个单元格。<br>      table中的属性，border表格的边框，cellspacing表示表格的单元格之间的距离，cellpadding表示内容到单元格之间的内间距，bordercolor边框颜色，bgcolor表格的背景颜色，width宽度，height高度。<br>      行占位符和列占位符的用法：操作合并单元格的方法<br>      行占位符rowspan–占行成列的效果。<br>      列占位符colspan–占列成行的效果。<br>      切记一点：使用合并单元格，要先判断占行还是占列，然后添加占位符，删除对应的占位符。<br>  15、在表格中的thead标签，只可以用对其方式控制水平位置的变化，而不能进行样式的修饰。<br>      在表格中的tbody标签，使用方法遵循表格中tr和td内容显示，使用属性也都生效。<br>      在表格中的tfoot表示页脚，页脚中也可以用tr和td去显示内容。可以使用对齐方式。<br>  16、表单form标签，表单是搜集数据的，是外联元素，属性action表示将表单搜集的输入的内容传递到的目的地路径。<br>      属性method表示，把搜集的数据用何种方式传递到action定义的地址中去。<br>      在表单中，有三个主要的标签：input输入框   select选择下拉框  textarea文本域<br>      注意：这三个标签都要被form标签去包含。<br>      在input中最重要的是type属性，type属性表明是何种表单元素。<br>      <label for="tiger">用户名：</label><br>      <input type="text" value="请输入您的账号" id="tiger" maxlength="5"><br>解释：type=”text”表明这是一个可以输入文本的输入框，value文本框中默认的内容，id给文本框加上id，maxlength表示这个文本框最大输入几个字符。因为html中所有内容要被包含，所以添加label标签包含用户名，label中属性for的值对应相关表单的id值，只能对应id，不能对应别的参数，id必须使用英文，不得使用汉字。<br>      <input type="password" id="pwd" value="******"><br>      密码的type属性是password！<br><label for="man">男：</label><br><input type="radio" id="man"><br>单选的type值是radio，为实现单选的效果，必须为input添加name属性。name值一致，才能出现单选的效果。<br>     <input type="checkbox"><br>多选框的type值为checkbox，表示可以多个选择。<br>     <input type="file">type为file是上传文件的按钮。<br>    <input type="submit" value="提交">type为submit是提交按钮，点击提交按钮，会把form搜集的文件通过method定义的方式传递到action定义的地址去。<br>     <input type="reset" value="提交">type为reset重置，会把输入的内容清空。<br>    <input type="button" value="提交">type为button按钮，单纯点击，没有效果。<br>    按钮也可以直接作为标签使用–如：<button>按钮</button><br>17、表单中的下拉菜单select标签，包含的是option标签，option的属性有selected=”selected”选择默认的选项。<br>18、表单中的textarea表示文本域，rows表示文本域的高度，cols表示文本域的宽度。<br>总结：表单中的form是外联元素，而form中所有的内容都是内联元素。换行要用br强制换行。<br>表单的高级应用：<br> 表单中在HTML5中新增的input中type的属性：<br>   1、email，强制定义网页中的必须输入邮箱。如：<input type="email"><br>   2、number，强制定义输入的是数字，数字可以增加或减少。如：<input type="number"><br><br>   3、输入日期格式，year年，month月，day日，week周，time时间，datetime日期加时间格式：<br>      如：<input type="year"><br>   4、表示控制范围：<input type="range">，min属性表示最小，max表示最大<br>   5、只读的表单：<input type="text" value="张三很坏" readonly="readonly"><br> 表单中新增的属性：<br>    placeholder属性，当输入内容，默认的内容就不显示。如：<input type="text" placeholder="点我你看看我"><br>    required属性，设置表单中不能为空，必须输入内容。如：<input type="text" required="required" value="这个不能为空啊"><br>    6、label标签用来将内容和表单中的input进行绑定，利用label中for属性的值要和input中的id值对应，这样点击label的内容，就可以<br>       把光标设置在input的文本框中。<br>19、form中的fieldset标签包含legend标签，显示效果是美化的表单，线在文字中间，包含form中所有的内容。</p><form action="#" method="post">       <fieldset id>           <legend>注册界面</legend>           <label for="name">用户名：</label>           <input type="text" id="name" value="请输入内容">       </fieldset>    </form>       网页中的多媒体信息和新增HTML标签：   1、HTML5新增标签：这些标签都是放在body中的内容部分。      header--这个标签表示网页的头部信息，头部一般放网页的logo标志和其他相关信息。      nav导航标签--一般放网页中的导航信息。      article标签--表示网页中主要的内容。      section定义内容中的节，自然段。      aside--表示和内容相关的内容。如左侧是站内导航，右侧是关于导航的详细信息。      footer--表示网页的底部，一般放网页中的版权和警告信息。   2、关于网页中的多媒体信息：      bgsound标签控制网页背景音乐。<bgsound src="video/1.mp3"></bgsound>      audio标签网页中可见的mp3的播放：      <audio autoplay="autoplay" controls="controls">             <source src="video/1.mp3">         </audio>     autoplay自动播放，controls显示播放控件。   3、关于网页中的视频播放：      object标签、video标签      <video autoplay="autoplay" controls="controls">             <source src="video/1.mp4">         </video>     object标签： <object class id="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,19,0" width="500" height="440">  <param name="movie" value="flvplayer.swf">  <param name="quality" value="high">  <param name="allowFullScreen" value="true">  <param name="FlashVars" value="vcastr_file=video/abc.flv&LogoText=www.iloveyou.com&BufferTime=3&IsAutoPlay=0">  <embed src="flvplayer.swf" allowfullscreen="true" flashvars="vcastr_file=video/abc.flv&LogoText=www.iloveyou.com&IsAutoPlay=0" quality="high" pluginspage="http://www.macromedia.com/go/getflashplayer" type="application/x-shockwave-flash" width="500" height="440"></object>               <video width="600" height="300" controls src="birds.mp4"></video>        <hr>        <video width="200" height="100" controls>            <source src="birds.mp4" type="video/mp4">        </video>   4、在网页中嵌套其他网页：       <iframe src="http://www.baidu.com" width height></iframe><p>网页中的CSS样式：对于网页内容进行修饰。<br>CSS文件叫层叠样式表，用来修饰网页中内容的样式，层叠表示修饰样式是多层存在的。<br>   a、CSS的文件扩展名是.css，在站点的css目录中建立层叠样式表的文件，一般用css.css或者style.css命名。<br>CSS样式可以修饰的内容是：内联元素标签和外联元素的标签。<br>     内联元素的特征：不会换行，重点在修饰，用css修饰内联元素自身之外的属性。<br>     外联元素的特征：自动换行，重点在布局，用css修饰外联元素进行布局时的宽度高度和位置等信息。<br>  总结：所有的HTML标签分为单标签和双标签，这两种标签都能用css修饰。<br>        所有的html标签分为内联元素和外联元素（块级元素），分别用css修饰各种的特点。<br>   b、使用css的方法，在css目录简历style.css的文件。然后再index.html入口文件的head部分，添加link的标签，link中的href属性来关联css的样式表文件。<br>      <link rel="stylesheet" type="text/css" href="css/style.css"><br>      rel属性表示样式的标签，tyle属性定义css的文本，href定义连接外部文件的路径。<br>   测试是否连接成功：<br>     在style.css中测试body{ background-color: blue;}，浏览器如果显示蓝色，表示连接成功。<br>     其中body叫css的选择符，在{ }中的background-color表示body的背景颜色，blue设置body的背景颜色为蓝色。<br>  注意：使用css时，第一行切记添加定义css的字符集。@charset “utf-8”;<br>上节课回顾：<br>   1、网页引用CSS文件的方法：<br>      a、link关联法，link关联法是网页文件index.html和style.css进行关联，也是唯一符合SEO规范的CSS引用方法。<br>      b、在网页文件index.html中的head标签中写入style的双标签，标签中写具体的css样式。<br>        例如：<style type="text/css"><br>        body{ background-color: green;}<br>           </style><br>      c、在网页文件index.html中的head标签中写入style的双标签，标签中写具体的css的外部引用文件。<br>        例如：<style type="text/css"></p><pre><code>       &lt;/style&gt;    注意：这种方法只能引入css的文件。  d、在网页的body中，双标签在首标签中插入style的属性，引出css的属性和值。    例如：&lt;h1 style=&quot;color: red; font-size: 160px;&quot;&gt;我是一个标题&lt;/h1&gt;   注意：每一个css属性写完，都要用分号结束。</code></pre><p>总结：使用CSS层叠样式表，可是实现网页的结构和样式的分离，方便我们对于网站进行维护。也就是说index.html中专门写html代码，在style.css中只写css样式，如果对于样式进行维护，直接打开style文件即可，无需考虑index.html的代码。<br>   2、css中的选择符：<br>      选择符{属性1：值1；属性2：值2；…}<br>   3、常用的选择符：<br>      a、类型选择符、元素选择符、标签选择符<br>      例如：在index.html中：<h1>我是内容</h1><br>            在style.css中：h1{color:red}<br>      b、id选择符，给html的标签设置id属性，在css中，用#id名称进行引用。<br>      例如：在index.html中：<h1 id=“tiger”>我是内容</h1><br>            在style.css中：#tiger{color:red}<br>      注意：id选择符具有唯一性，所以id的名称只能定义一次。id并不是只能使用一次。<br>      例如：在index.html中：<br>          <h1 id="tiger">我是另外一个h1</h1><br>      <p id="tiger">我是段落</p><br>            在style.css中：#tiger{color:red}<br>      c、class选择符，类选择符，类选择符可以定义一次，可以多次使用。在css中用.加类名引用。<br>          例如：在index.html中：<br>          <h1 class="tiger">我是另外一个h1</h1><br>      <p class="tiger">我是段落</p><br>             在style.css中：.tiger{color:red}<br>      注意：class选择符和id选择符的区别：class可以定义多个，id只能定义一个。<br>        案例：  在html中的代码：<br>                 <h1 class="tiger apple small">我是另外一个h1</h1><br>             <p id="banana daxiao">我是id的段落</p><br>             在css中：<br>                 .tiger{ font-size: 30px;}<br>             .apple{ color: red;}<br>             .small{ text-decoration: underline;}<br>             #banana{ color: green;}<br>             #daxiao{font-size: 70px;}<br>        d、交集选择符，由类型选择符和id选择符或类型选择符和class选择符组合使用生成的选择符。<br>         例如：在index.html中：<br>          <h1 class="tiger">我是另外一个h1</h1><br>      <p class="tiger">我是段落</p><br>             在style.css中：.tiger{color:red;}<br>                            h1.tiger{属性：值}<br>                             p.tiger{属性：值}<br>           注意交集选择符p.tiger{属性：值}一定类型选择符和类名引用相连，不能有空格。<br>        e、并集选择符–表示平级的选择符之间的关系。<br>           在html中：   <h1>我是另外一个h1</h1><br>                    <p>我是id的段落</p><br>           在css文件中： h1,p{color: red;}   —表示h1的标签和p的标签都遵循这个属性。<br>        f、混合选择符，交集选择符，类型选择符，id选择符，class选择符，同时使用。<br>           在css中：h1.apple,h5#banana{}–h1的apple类，和h5的id为bananan的都遵循此属性。<br>        g、包含选择符，也叫后代选择符—表示包含关系的选择符<br>            在html中： <h1><p>hello</p></h1><br>            在css中：h1 p{color: red;}–表示h1中包含的p标签的属性。<br>        h、*通配符–表示所有的类型选择符都遵循此属性。<br>           *{属性：值}<br>  案例：在index.html中：<br>         <h1>八仙过海</h1><br>       <p><a href="">八仙</a>那天有空，想要<a href="#" class="yanse">过海</a>，<br>           于是一个一个的拿出<a href="#">法宝</a>，<br>           就<a href="#" class="yanse ziti">过海</a>了</p><br>        在CSS文件中：<br>         *{ font-size: 35px;}<br>        h1{ color: red;}<br>         p{ font-size: 18px;}<br>       p a{ color: blueviolet;}<br>     p a.yanse{ color: darkkhaki; text-decoration: none;}<br>    p a.ziti{font-style: italic; font-weight: bold;}</p><p>在CSS中的选择符的优先级：当选择符定义同一个标签的元素，鉴别以哪种选择符的属性为准。<br>   id选择符&gt;class选择符&gt;类型选择符&gt;通配符*<br>  优先级中行内样式优先级最高！<br>  注意：在选择符中，行内样式定义的CSS距离内容最近，所以优先级最高，也就是县官不如现管！<br>        因为ID具有唯一性，而class可以定义多个，所以id大于class选择符。<br>        class可以单独定义到具体的html标签，所以针对性比类型选择符强，所以优先级比类型选择符高。<br>        <em>代表全局，范围太广泛，所以优先级是最低的。当我们使用样式，针对大多数的样式，可以使用</em><br>        进行定义，个别的样式单独存在的一种样式用id定义，凡是出现多次相同样式用class定义。<br>        当用<em>进行定义了属性，其他选择符定义的属性和</em>相同，就会把*通配符定义的属性冲突掉。<br>  案例：在index.html中：<br>          <h1>实训室教师使用管理规定</h1><br>      <ol><br>          <li class="yanse">不准吃饭1不准吃饭1不准吃饭1不准吃饭1</li><br>          <li>不准吃饭2不准吃饭2不准吃饭2不准吃饭2</li><br>          <li class="yanse">不准吃饭3不准吃饭不准吃饭不准吃饭</li><br>          <li>不准吃饭4不准吃饭不准吃饭不准吃饭</li><br>          <li class="yanse">不准吃饭5不准吃饭不准吃饭不准吃饭</li><br>          <li>不准吃饭6不<b class="italic">准吃</b>饭不准吃饭</li><br>          <li>不准吃饭7不准吃饭不准吃饭不准吃饭</li><br>          <li id="tiger">不准吃饭8不准吃饭不准吃饭不准吃饭</li><br>          <li>不准吃饭9不准吃饭<a href="#">不准吃饭</a>不准吃饭</li><br>          <li class="qingxie">不准吃饭10不准吃饭不准吃饭不准吃饭</li><br>      </ol><br>​       在css中的属性：<br>​          *{ color: blue; font-size: 28px;}<br>​      h1{font-size: 50px; font-family: “微软雅黑”;}<br>​      ol li.yanse{ color: red;}<br>​      ol li#tiger{ font-weight: bold;}<br>​      ol li.qingxie{ font-style: italic;}<br>​      ol li b{text-decoration: underline;}<br>​      ol li b.italic,ol li a{ color: darkgoldenrod;}<br>​    注意：font-family设置字体<br>​          font-size字体大小<br>​          font-weight: bold;字体加粗<br>​          font-style: italic;倾斜效果<br>​          text-decoration: underline;添加和删除下划线  underline是添加下划线，none是取消下划线</p><p> 上节课的回顾：CSS的引用四种方法，选择符的使用方法，常用的选择符，选择符的优先级</p><p>   关于DIV+CSS布局：<br>     内联元素修饰，外联元素布局。如果要修饰内联元素标签，就要使用b标签或者u标签，修饰不换行的内容，就要用内联标签，但内联标签不干净，自带有修饰效果，所以我们需要一个干净的没有任何自带修饰效果的内联元素标签，w3c组织提出干净的内联标签这个标签是span标签。<br>     与之相对象和匹配的，提出了一个干净的会自动换行的外联元素的标签，叫div标签。<br>     span内联+div的外联标签都是干净的标签，div专门用于布局，span专门用于修饰。<br>     因为网页中的每一块内容都是独立存在的，每一块都是布局，所以针对id选择符的特点，我们在div标签中如果要修饰div的css属性，用id选择符。修饰内联的span用class选择符。因为类可以有多个，又专门进行样式修饰使用的，所以span中使用class选择符。<br>     授课思路：先讲解内联元素的CSS属性有哪些？再讲解修饰外联元素的属性有哪些？<br>  内联元素的属性：<br>   a、字体font：<br>   font-family设置字体   font-size字体大小   font-weight: bold;字体加粗    font-style: italic;倾斜效果  color字体颜色<br>   b、文本text：<br>   text-align文本对齐方式，左中右   text-decoration:文本的下划线属性  text-indent首行缩进<br>   c、锚伪类，控制鼠标经过，鼠标选中，鼠标访问过后的效果<br>                a:link{color:red}–默认样式<br>                a:hover{ color: red;}—-鼠标经过<br>        a:active{ color: green;}–鼠标选定，手点击别松<br>        a:visited{color: yellow; }–鼠标点一下<br>    在网页使用锚伪类时，顺序不能改变，分别就是鼠标经过，鼠标选定，鼠标点击。<br>修饰外联元素的CSS属性：外联元素是一块，所以也叫块级元素，所以就有了网页中的盒子模型。<br>     盒子模型是指网页中的内容，盒子模型–border边框、content内容、内间距padding、margin外间距。所有的外联元素和内联元素都可以理解为一个盒子的存在。盒子模型中有宽度、高度、边框线、内间距、外间距<br>    a、width宽度，宽度有固定宽度和自适应宽度auto两种。<br>       width：200px;固定宽度，width：100%自适应宽度。<br>    inherit(继承)宽度，当父级的盒子指定固定宽度，而包含的盒子不指定宽度，包含的盒子会继承父级盒子的宽度。由此可见，宽度可以继承，高度可以被内容撑起。<br>    注意：只有外联元素才有宽（设定宽度网页效果会生效）。内联元素也有宽高，但是是随着内容而变化的宽高，也就是指定内联元素的宽高是不会有效果的。<br>    b、height高度，高度有固定高和内容撑起的高两种。<br>       height：200px；固定的高度。高度的属性不写，真实的高度会被内容撑起。<br>    注意：宽度的特征是会继承，高度的特征是不会继承父级元素的高，但会被内容撑起来。<br>    内容可能超过父级元素标签的宽高，所以我们用overflow控制内容溢出的属性。<br>    overflow的属性一般在父级元素标签中使用：<br>    overflow: hidden;当子级的标签超过父级标签，超出的部分隐藏掉。<br>    overflow: auto;超出部分会显示滚动条，如果不超出，就不显示滚动条。<br>    overflow: scroll;无论是否超出，都强制显示滚动条。<br>   总结：当使用宽度和高度的属性时，尽量写父级元素大盒子的宽度，别写高度，里面的小盒子只写高度，别写宽度。<br>          当宽度高度都是固定的高度，要使用overflow的属性。<br>    c、边框线border，可以同时定义四条线，可以定义单独一条线，一般我们采用简写的方式表示边框：<br>       border: dashed 1px red;<br>       注意：线的类型dashed虚线   dotted点线  solid实线  double双线（线的粗细不能低于1px）<br>    d、padding内间距，表示边框到内容之间的距离。设定盒子的内间距，会撑大盒子。<br>       内间距可以定义四个方向：当按照顺时针的方式进行每个padding的设定，盒子会被撑大相应的尺寸，和内容的间距，是padding-top和padding-left是真实的间距。当定义了padding-top间距，padding-bottom值失效（虽然值失效，这里失效是内容和边框间距失效，但撑大盒子的值并未失效），依次类推，定义padding-left，padding-right的值失效，但撑大效果并未失效。<br>       padding的简写效果：<br>       padding：10px—内间距四个方向都是10px间距<br>       padding：10px 20px；–内间距上下10px，左右20px间距。<br>       padding：10px 20px 30px；–内间距上10px，左右20px，下30px；<br>       padding：10px 20px 30px 40px–上10px，右20px，下30px，左40px（顺时针方向指定）<br>    固定宽高的盒子尺寸=宽度+内间距+border线<br>   总结：调整内容在大盒子中的位置，可以采用内间距padding，但内间距会撑大盒子，所以一定有属性也可以改变内容的间距，且不撑大盒子。这就是内容的外间距。<br>    继承大盒子的宽度的小盒子设定内间距为什么不受内间距撑大盒子的影响？<br>     当继承的宽度（不是固定设定的宽度）设定内间距不会撑大盒子。<br>    e、外间距margin，表示内容到边框的间距。简写的方式和内间距一样，也是顺时针进行设定。<br> padding的简写效果：<br>       margin：10px—内间距四个方向都是10px间距<br>       margin：10px 20px；–内间距上下10px，左右20px间距。<br>       margin：10px 20px 30px；–内间距上10px，左右20px，下30px；<br>       margin：10px 20px 30px 40px–上10px，右20px，下30px，左40px（顺时针方向指定）<br>    注意：外联元素和内联元素都可以使用内间距和外间距，但生效的位置不一样。<br>          外联元素进行内间距和外间距生效的是四个方向。<br>          内联元素的内间距生效的距离是左右和下，外间距生效的范围是水平的左右。<br>          利用外间距margin：0 auto；表示一个盒子的居中，但要注意，没有固定宽度的盒子是无法居中的。<br>   通常的盒子模型指的是内联元素还是外联元素？<br>    盒子模型–border边框，content内容，内间距padding，外间距margin<br>    内联元素也可以理解为盒子模型，因为都有边框内容和间距，但要注意，内联元素宽和高都是依靠内容撑起的，内间距依然撑大内联元素的盒子，外间距可以控制内联元素的外间距，但生效方式只有水平横向的位置。<br>    课堂案例操作习惯使用div外联元素进行演示的原因是在div表示盒子模型中的每个属性设定都有效果，所以用div验证盒子模型。用div宽度和高度都可以设定，但内联宽高无法设定。<br>    f、浮动float–盒子脱离了body文档流进行水平方向的移动。<br>       float：left左浮动     float：right右浮动     float：none不浮动<br>       清除浮动clear：清除浮动并不是设定盒子不再浮动回到body层，而是清除前面盒子布局对于后面盒子布局的影响，可以操作浮动层的内容换行。<br>      <div id="tiger"></div>    #tiger{ clear: both;}<br>​    g、定位position–盒子脱离body的文档流，进行二维坐标的定位。二维坐标就是top上，下bottom，左left，右right，当使用定位时，上下二维坐标取一个值，左右二维坐标取一个值，就能定位到一个具体的位置。<br>​      相对定位relative：相对盒子当前的位置进行移动，原先位置内容消失，脱离文档流。<br>#box{width: 200px;height: 200px; background: red;position: relative;top: 10px;left: 10px;}<br>​        a:hover{position: relative;top: 1px; left: 1px;}<br>    <div id="box"></div><br>​    <a href="#">搜狐</a><br>​      绝对定位absolute：相对body的边框进行移动，原先位置内容取消，脱离文档流。<br>​      注意：当大盒子定义了相对定位，小盒子定义绝对定位，小盒子的绝对定位不再参照body，而是参照大盒子进行移动。<br>​      固定定位fixed：始终参照body的位置进行定位。<br>​     使用定位时，如果定位的盒子发生了重叠，使用z-index来表示盒子层叠的优先级。<br> #box{width: 300px;height: 300px; background: red; position: relative; top: 10px; left: 10px;z-index: 1;}<br>#son{ width: 200px; height: 200px; background: blue; position: relative; top: -80px; left: 80px; z-index:0 ;}<br>#small{width: 100px;height: 100px; background: green;  position: relative; top: -250px; left: 250px;z-index: -1;}<br>           <div id="box"></div><br>       <div id="son"></div><br>       <div id="small"></div><br>​     h、visibility元素是否可见: hidden隐藏;visibility: hidden;表示盒子被隐藏但会有占位的效果。<br>​     j、display转换：实现内联元素和外联元素的相互转换。<br>​        display: inline;外联转内联<br>​        display: block；内联转外联<br>​        display：inline-block；行内块级元素，在一行显示，但可以定义宽高。<br>   网页中的列表、背景和控制图片的CSS属性：<br>   列表分为三类–有序列表ol   无序列表ul  自定义列表dl<br>​           注意：分清楚有序列表和无序列表的区别？使用列表要注意列表是有默认的内间距的。<br>​        默认有间距的是body的标签、h的标题标记、ul列表都有默认间距。无序列表中，列表符号和列表的内容默认不是一体的<br>​      列表可以用来制作网页中的新闻列表和菜单栏：使用列表时用包含选择符，先写列表的框架，再写列表的CSS选择符。<br>​      ul是外联元素，可以定义宽度，高度，实现居中对齐。<br>​      li是ul标签的子级元素，会继承ul的宽度，但注意ul有默认的内左侧间距，所以li是ul设定的宽度。可以利用通配符*清除默认的间距。 定义li的color颜色属性，列表符号的颜色会变化。<br>​      list-style列表符号的样式: square矩形点;none清除列表符号。<br>​      list-style-image: url(img/list.gif)列表图片的设定。<br>​      list-style-position: inside;设定符号在li里面，和li是一体的。<br>​      line-height设定行高，设定的是每行的高度。<br>   网页中的背景background：背景颜色，背景图片，背景图片是否重复，背景图片坐标，背景图片锁定。<br>   background-color: #ccc;背景颜色<br>   background-image: url(img/abb.jpg);背景图片，默认平铺效果<br>   background-repeat:no-repeat;背景图片重复<br>   background-position:1600px 30px;背景图片定位<br>   background-attachment: fixed;  背景图片锁定<br>   背景的使用一定要写简写的方式：<br>   background：#ccc url(路径) reapeat left left fixed；注意：背景图片的优先级高于背景颜色。<br>   背景填充法和CSS取图：<br>​     background: url(img/timg.jpg) no-repeat -441px -303px;<br>   网页中的图片img和表单form：<br>  a、网页中的图片多使用class选择符去引用，网页中通常能使用的属性是src属性和alt属性（图片信息的描述）<br>  b、img–src属性   link–href属性   a–href属性。切记不要使用width和height属性修饰图片的尺寸。<br>   网页中的form表单：表单form由三部分构成-input输入、select下拉菜单、textarea文本域，表单是外联元素，但里面的input、select、textarea都是内联元素不换行，所以使用表单时必须写form的标签，否则无法控制文本框input等内容的布局位置。<br>  c、行高的属性line-height：一行的高度，通过使用行高可以控制内容的行间距。如果一个盒子中有高度，而行高和高度一致，那么盒子中的文本内容会在盒子垂直居中的位置。也就说，文本的垂直居中使用vertical-align是不生效的，是通过行高进行设定的。<br>​     注意：内联元素不能设定高度，但是可以设定行高。<br>​           现在讲到的知识点可以使用vertical-align的元素有哪些？图片，表单（特殊的内联元素）。<br>​           特殊的内联元素特点–横在排列，在一行显示不换行，但是却可以控制元素的宽高。<br>  d、手型工具cursor:  默认手型 pointer; 帮助help；<br>  e、网页中的导航菜单：使用ul制作。利用li把列表的点清除掉，转换a标签变成块级元素，设定宽高，设定水平和垂直对齐方式，设置每个a标签的外间距即可。</p></style></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL数据库</title>
    <link href="undefined2019/10/30/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/10/30/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="MySQL数据库增删改查SQL语句"><a href="#MySQL数据库增删改查SQL语句" class="headerlink" title="MySQL数据库增删改查SQL语句"></a>MySQL数据库增删改查SQL语句</h3><h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><pre><code class="mysql">show databases; </code></pre><h5 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h5><pre><code class="mysql">use 数据库名;</code></pre><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><pre><code class="mysql">CREATE DATABASE 数据库名;</code></pre><h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><pre><code class="mysql">DROP DATABASE 数据库名;</code></pre><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><pre><code class="mysql">create table 表名(    列名1 类型(长度) [约束],    列名2 类型(长度) [约束],    ……);</code></pre><h5 id="长度区别"><a href="#长度区别" class="headerlink" title="长度区别"></a>长度区别</h5><p>int类型带长度：不影响存取值，即使设定的值超出了长度的范畴，也能存，如果没有达到设定的长度，则使用空格自动填充到设定的长度<br>char类型：不可变字符，设定的长度就是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，使用空格填充到设定的长度<br>varchar：可变字符，设定的长度同样是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，不会使用空格填充，实际多长就是多长</p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><pre><code class="mysql">DROP TABLE 表名;</code></pre><h5 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h5><p>1.非空约束    NOT NULL</p><p>2.默认值约束  DEFAULT ‘男’</p><p>3.唯一约束    UNIQUE4.主键约束    PRIMARY KEY</p><h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h5><p>DESC 表名</p><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><h5 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h5><pre><code class="mysql">Alter table 表名  change  列名  新列名 类型;</code></pre><h5 id="修改列类型"><a href="#修改列类型" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  change 列名  列名  新类型;</code></pre><h5 id="修改列类型-1"><a href="#修改列类型-1" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  modify  列名  新类型;</code></pre><h5 id="数据查询-单表"><a href="#数据查询-单表" class="headerlink" title="==============================数据查询-单表================================="></a>==============================数据查询-单表=================================</h5><h5 id="查询表中全部信息"><a href="#查询表中全部信息" class="headerlink" title="查询表中全部信息"></a>查询表中全部信息</h5><pre><code class="mysql">select * from 表名;</code></pre><h5 id="查询表中指定列的信息"><a href="#查询表中指定列的信息" class="headerlink" title="查询表中指定列的信息"></a>查询表中指定列的信息</h5><pre><code class="mysql">select 列1,列2 from 表名;</code></pre><p>语句的执行顺序：from—&gt;select</p><h5 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h5><pre><code class="mysql">select distinct 列…. From 表名;</code></pre><h5 id="拼接结果"><a href="#拼接结果" class="headerlink" title="拼接结果"></a>拼接结果</h5><pre><code class="mysql">select concat(列1,列2) from 表名;</code></pre><h5 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h5><p>1.乘法和除法的优先级高于加法和减法<br>2.同级运算的顺序是从左到右<br>3.表达式中使用”括号”可强行改变优先级的运算顺序</p><pre><code class="mysql">select 列1[+-*/]列2 from 表名;</code></pre><h5 id="设置别名-注意：关键字as可以省略"><a href="#设置别名-注意：关键字as可以省略" class="headerlink" title="设置别名(注意：关键字as可以省略)"></a>设置别名(注意：关键字as可以省略)</h5><pre><code class="mysql">select 列 as 别名 from 表名;  select 列 别名 from 表名;     </code></pre><p> 语句的执行顺序：from—&gt;select</p><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><pre><code class="mysql">select 列… from 表名 where 条件;  </code></pre><h5 id="条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt"><a href="#条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt" class="headerlink" title="条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )"></a>条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )</h5><pre><code class="mysql">where 列  比较运算符  值;</code></pre><p>注意:字符串、日期需使用单引号括起来<br>语句的执行顺序：from—&gt;where—&gt;select</p><h5 id="逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或"><a href="#逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或" class="headerlink" title="逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )"></a>逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )</h5><pre><code class="mysql">where 条件1  逻辑运算符  条件2;  where not 条件; </code></pre><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><pre><code class="mysql">where 列 between 条件1  and 条件2;        </code></pre><p>//列在这个区间的值where 列 not between 条件1 and 条件2;    </p><p>//不在这个区间where !( 列 between 条件1 and 条件2 );    </p><p>//同样表示不在这个区间</p><h5 id="集合查询-判断列的值是否在指定的集合中"><a href="#集合查询-判断列的值是否在指定的集合中" class="headerlink" title="集合查询( 判断列的值是否在指定的集合中 )"></a>集合查询( 判断列的值是否在指定的集合中 )</h5><pre><code class="mysql">where 列 in(值1,值2);      </code></pre><p>//列中的数据是in后的值里面的where 列 not in(值1,值2);   </p><p>//不是in中指定值的数据</p><h5 id="NULL值查询-注意：列中值为null不能使用-去查询"><a href="#NULL值查询-注意：列中值为null不能使用-去查询" class="headerlink" title="NULL值查询( 注意：列中值为null不能使用=去查询 )"></a>NULL值查询( 注意：列中值为null不能使用=去查询 )</h5><pre><code class="mysql">where 列 is null;  </code></pre><p>//查询列中值为null的数据</p><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><h5 id="：表示0到多个字符，示例："><a href="#：表示0到多个字符，示例：" class="headerlink" title="%：表示0到多个字符，示例："></a>%：表示0到多个字符，示例：</h5><pre><code class="mysql">where 列 like &#39;%0&#39;;  </code></pre><p> //表示以0结尾where 列 like  ‘0%’;   </p><p>//表示以0开头where 列 like  ‘%0%’;  </p><p> //表示数据中包含0</p><h5 id="：表示一个字符，可多次使用，示例："><a href="#：表示一个字符，可多次使用，示例：" class="headerlink" title="_：表示一个字符，可多次使用，示例："></a>_：表示一个字符，可多次使用，示例：</h5><pre><code class="mysql">where 列 like &#39;%0_&#39;;   </code></pre><p>//数据结尾第二位是0</p><h5 id="结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序"><a href="#结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序" class="headerlink" title="结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)"></a>结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)</h5><pre><code class="mysql">where 条件 order by 列 [asc/desc]</code></pre><p>语句的执行顺序：from—&gt;where—&gt;select—&gt;order by</p><h5 id="分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数"><a href="#分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数" class="headerlink" title="分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )"></a>分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )</h5><pre><code class="mysql">where [条件] limit beginIndex,pageSize;</code></pre><p>ex：每页显示3条数据<br>第一页: SELECT * FROM 表名 LIMIT 0,3    –0,1,2<br>第二页: SELECT * FROM 表名 LIMIT 3,3    –3,4,5<br>第三页: SELECT * FROM 表名 LIMIT 6,3    –6,7,8<br>第四页: SELECT * FROM 表名 LIMIT 9,3    –9,10,11<br>  ……<br>第七页: SELECT * FROM 表名 LIMIT 18,3   –18,19,20</p><h5 id="beginIndex公式：-当前页数-1-pageSize"><a href="#beginIndex公式：-当前页数-1-pageSize" class="headerlink" title="beginIndex公式：(当前页数-1)*pageSize"></a>beginIndex公式：(当前页数-1)*pageSize</h5><h5 id="聚集函数-作用于一组数据，并对一组数据返回一个值"><a href="#聚集函数-作用于一组数据，并对一组数据返回一个值" class="headerlink" title="聚集函数( 作用于一组数据，并对一组数据返回一个值 )"></a>聚集函数( 作用于一组数据，并对一组数据返回一个值 )</h5><h5 id="COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"><a href="#COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值" class="headerlink" title="COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"></a>COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值</h5><h5 id="MAX-统计计算最大值"><a href="#MAX-统计计算最大值" class="headerlink" title="MAX:  统计计算最大值"></a>MAX:  统计计算最大值</h5><h5 id="MIN-统计计算最小值"><a href="#MIN-统计计算最小值" class="headerlink" title="MIN:  统计计算最小值"></a>MIN:  统计计算最小值</h5><h5 id="SUM-统计计算求和"><a href="#SUM-统计计算求和" class="headerlink" title="SUM:  统计计算求和"></a>SUM:  统计计算求和</h5><h5 id="AVG-统计计算平均值"><a href="#AVG-统计计算平均值" class="headerlink" title="AVG:  统计计算平均值"></a>AVG:  统计计算平均值</h5><h5 id="分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后"><a href="#分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后" class="headerlink" title="分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )"></a>分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )</h5><pre><code class="mysql">select 聚集函数 from 表名 where [条件] group by 列 having 分组后的条件</code></pre><p>语句的执行顺序：FROM—&gt; WHERE—&gt;group by—-&gt;Having—&gt;SELECT–&gt;ORDER BY</p><h5 id="Where和having的区别："><a href="#Where和having的区别：" class="headerlink" title="Where和having的区别："></a>Where和having的区别：</h5><h5 id="Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算"><a href="#Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算" class="headerlink" title="Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算"></a>Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算</h5><h5 id="Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤"><a href="#Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤" class="headerlink" title="Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)"></a>Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)</h5><p>注意：使用having的时候，它是可以使用别名的</p><h5 id="数据查询-多表"><a href="#数据查询-多表" class="headerlink" title="===============================数据查询-多表==============================="></a>===============================数据查询-多表===============================</h5><h5 id="交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积"><a href="#交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积" class="headerlink" title="交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积"></a>交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积</h5><p>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p><pre><code class="mysql">select *  from 表1,表2</code></pre><h5 id="内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据"><a href="#内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据" class="headerlink" title="内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据"></a>内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据</h5><pre><code class="mysql">select * from 表1,表2  where 表1.字段=表2.字段;  </code></pre><p>//隐式内连接,使用where条件消除笛卡尔积</p><pre><code class="mysql">select * from 表1 [inner] join 表2 on 表1.字段=表2.字段;</code></pre><p> //显式内连接,如果是多张表，则一直在join..on后依次添加join..on即可,inner关键字可被省略</p><h5 id="外连接：左外连接、右外连接、全外连接"><a href="#外连接：左外连接、右外连接、全外连接" class="headerlink" title="外连接：左外连接、右外连接、全外连接"></a>外连接：左外连接、右外连接、全外连接</h5><h5 id="左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"><a href="#左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解" class="headerlink" title="左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"></a>左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段;   </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"><a href="#右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解" class="headerlink" title="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"></a>右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段;  </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"><a href="#全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名" class="headerlink" title="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"></a>全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名</h5><p>多用在分类数据、省市县分类数据、权限…</p><pre><code class="mysql">select 表1.字段1,表2.字段2 from 表名 as 表1,表名 as 表2 where 表1.字段1=表2.字段2 </code></pre><h5 id="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"><a href="#子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套" class="headerlink" title="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"></a>子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套</h5><pre><code class="mysql">select * from (select * from 表名) as 别名select * from where 条件</code></pre><p>//条件中包含查询语句</p><p>注意：1.查询结果的虚拟表必须取别名<br>           2.字段与关键字一样，冲突时，需要给字段名加``,(Esc键下面、1的左边)<br>           3.如果给虚拟结果表中的字段取了别名，则对虚拟结果表查询时，应该用 表别名.虚拟表字段别名</p><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="===============================插入数据==============================="></a>===============================插入数据===============================</h5><pre><code class="mysql">insert into 表名(字段1,字段2..) values(值1,值2…);   </code></pre><p>注意： 1.如果插入的表中的主键是自增类型的，可以不用插入值<br>            2.如果主键是非自增 ，插入的数据则是填补主键字段值空余的值<br>            3.如果主键设置了自动递增，会从主键字段最大值开始插入数据</p><h5 id="其他插入方式："><a href="#其他插入方式：" class="headerlink" title="其他插入方式："></a>其他插入方式：</h5><pre><code class="mysql">insert into 表名(字段1,字段2) values(值1,值2),(值1,值2);    </code></pre><p>//插入多条数据【MYSQL】insert into 表名 values(值1,值2);                    </p><p>//针对全表所有字段进行插入操作insert into 表名(字段) select 字段 from 表2;         </p><p>//查询结果插入insert into 表名 select 字段 from 表2;               </p><p>//查询结果，全表插入</p><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="===============================修改数据==============================="></a>===============================修改数据===============================</h5><pre><code class="mysql">update 表 set 字段=值 where 条件; </code></pre><p> //带条件修改指定数据，否则修改全表</p><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="===============================删除数据==============================="></a>===============================删除数据===============================</h5><pre><code class="mysql">delete from 表 where 条件; </code></pre><p>//删除数据带条件指定数据，否则删除全表数据</p><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="===============================数据备份==============================="></a>===============================数据备份===============================</h5><h5 id="在命令行窗口进行，若操作系统版本高，则使用管理员模式"><a href="#在命令行窗口进行，若操作系统版本高，则使用管理员模式" class="headerlink" title="在命令行窗口进行，若操作系统版本高，则使用管理员模式"></a>在命令行窗口进行，若操作系统版本高，则使用管理员模式</h5><p>导出：</p><p>mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地</p><p>ex:         mysqldump -uroot -proot jdbcdemo&gt; C:/shop_bak.sql<br>导入：</p><p>mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址</p><p>ex:         mysql -uroot -proot jdbcdemo&lt; C:/shop_bak.sql<br>使用可视化导入导出：<br>Navicat工具的导入和导出/Navicat工具的备份和还原</p><h5 id="数据索引"><a href="#数据索引" class="headerlink" title="===============================数据索引==============================="></a>===============================数据索引===============================</h5><h5 id="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"><a href="#索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。" class="headerlink" title="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"></a>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</h5><h5 id="什么列适合建索引？？"><a href="#什么列适合建索引？？" class="headerlink" title="什么列适合建索引？？"></a>什么列适合建索引？？</h5><p>1.表的主键、外键必须有索引；<br>2.数据量超过30000的表应该有索引；<br>3.经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4.经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5.索引应该建在选择性高的字段上；<br>6.索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </p><h5 id="sql语句创建和删除索引："><a href="#sql语句创建和删除索引：" class="headerlink" title="sql语句创建和删除索引："></a>sql语句创建和删除索引：</h5><p>创建索引: </p><p>CREATE INDEX 索引名称 ON 表名 (列名)</p><p>删除索引:<br>方式一：</p><p>DROP INDEX 索引名 ON 表名 </p><p>方式二:  </p><p>ALTER TABLE 表名 DROP INDEX 索引名</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Request案例</title>
    <link href="undefined2019/10/30/Request%E6%A1%88%E4%BE%8B/"/>
    <url>2019/10/30/Request%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Request案例代码："><a href="#Request案例代码：" class="headerlink" title="Request案例代码："></a>Request案例代码：</h3><p>（1）index.jsp</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;NewFile.jsp&quot; meshod=&quot;post&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;        多选：&lt;br&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;唱&quot;&gt;唱        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;跳&quot;&gt;跳        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;rap&quot;&gt;rap        &lt;input type=&quot;checkbox&quot; name=&quot;dx&quot; value=&quot;篮球&quot;&gt;篮球        &lt;br&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;input type=&quot;reset&quot; name=&quot;reset&quot; value=&quot;取消&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）NewFile.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;% request.setCharacterEncoding(&quot;UTF-8&quot;);String name=request.getParameter(&quot;user&quot;);String pwd=request.getParameter(&quot;password&quot;);String [] y=request.getParameterValues(&quot;dx&quot;);%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    用户名是：&lt;%=name %&gt;&lt;br&gt;    密码是：&lt;%=pwd %&gt;&lt;br&gt;    信息来源是：&lt;% for(int i=0;i&lt;y.length;i++){        out.println(y[i]);    } %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点总结</title>
    <link href="undefined2019/10/11/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/11/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章面向对象"><a href="#第二章面向对象" class="headerlink" title="第二章面向对象"></a>第二章面向对象</h2><p>1.面向对象：面向对象思想就是把一个项目，一件事情分成更小的项目，每一部分负责什么功能，最后再有这些部分组合成一个整体。</p><p>2.类的创建</p><pre><code class="java">    语法：public class 类名{}​      File---&gt;new---&gt;class---&gt;类名</code></pre><p>​      </p><p>3.创建对象</p><pre><code>类名 对象名=new 类名();​      对象名.方法名(); 对象名.属性</code></pre><p>4.构造方法：方法名和类名相同,没有返回值</p><pre><code>     public class 类名{​         public 类名(){}//主要的做用是初始化操作​      }</code></pre><p>5.构造方法重载</p><p>（1）构造方法的重载：方法名与类名相同，参数列表不同</p><p>（2）方法的重载：在同一个类中包含了两个或者两个以上的方法，它们的方法名相同，方法的参数个数，顺序，类型不同，则称这个方法被重载了，这个过程称为方法的重载。</p><p>（3）构造方法的作用：用来实现多种初始化行为。</p><pre><code>    public class 类名{​         public 类名(){}​         public 类名(String name,int age){}​      }</code></pre><p>6.构造方法的执行</p><pre><code>     new 类名();---&gt;执行构造方法​      super();---&gt;执行了父类的构造方法</code></pre><p>7.static静态修饰符</p><p>   （1）含义：static可以用来修饰属性，方法，和代码块。static修饰的变量属于这个类所有，即由这个类创建的所有对象共用一个static变量。通常把static修饰的属性和方法称为类属性（也可以称为类变量），类方法。不使用static修饰的属性和方法属于单个对象，通常称为实例属性，实例方法。</p><p>（2）要点：</p><p>​    1.在加载类的过程中，完成静态变量的内存分配，再执行静态代码块，两者是在创建对象之前执行的。</p><p>​    2.类属性和类方法可以通过类名和对象名访问，实例属性和实例方法只能通过对象名访问。</p><p>​    3.类方法只能访问类属性和其他类方法，</p><p>注意：静态方法中不能使用this和super关键字。</p><p>8.java内存（栈和堆，static，方法区，gc（垃圾回收机制））</p><p>9.八种基本数据类型：</p><pre><code>    byte  short   int   long    float   double   Boolean   char</code></pre><h2 id="第三章面向对象三大特征—封装"><a href="#第三章面向对象三大特征—封装" class="headerlink" title="第三章面向对象三大特征—封装"></a>第三章面向对象三大特征—封装</h2><h3 id="第三章-面向对象三大特征—封装"><a href="#第三章-面向对象三大特征—封装" class="headerlink" title="第三章 面向对象三大特征—封装"></a>第三章 面向对象三大特征—封装</h3><p>1.封装的概念：封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部的信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>2.封装的步骤</p><p>​      1.把属性私有化（private）</p><p>​      2.对这些属性设置get和set方法</p><p>​      3.调用处理这些方法</p><p>3.封装的作用与好处：</p><p>作用：避免一些用一些不合乎常理的操作</p><p>好处：</p><p>（1） 提高了安全性</p><p>（2） 提高了复用性</p><p>（3） 隐藏了实现细节</p><p>4.封装的案例:</p><pre><code class="java">/* 文件名: EncapTest.java */public class EncapTest{   private String name;   private String idNum;   private int age;   public int getAge(){​      return age;   }   public String getName(){​      return name;   }   public String getIdNum(){​      return idNum;   }   public void setAge( int newAge){​      age = newAge;   }   public void setName(String newName){​      name = newName;   }   public void setIdNum( String newId){​      idNum = newId;   }}/* F文件名 : RunEncap.java */public class RunEncap{   public static void main(String args[]){​      EncapTest encap = new EncapTest();​      encap.setName(&quot;James&quot;);​      encap.setAge(20);​      encap.setIdNum(&quot;12343ms&quot;);​      System.out.print(&quot;Name : &quot; + encap.getName()+ ​                             &quot; Age : &quot;+ encap.getAge());​    }}</code></pre><p>5.修饰符</p><p>​      public—&gt;公共的：在一个项目中都可以访问，权限最高</p><p>​      private—&gt;私有的：只能在本类中进行访问，权限最低</p><p>​      protected—&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类</p><p>​      default—&gt;默认的：同一个包能访问</p><h2 id="第四章-面向对象三大特征—继承"><a href="#第四章-面向对象三大特征—继承" class="headerlink" title="第四章 面向对象三大特征—继承"></a>第四章 面向对象三大特征—继承</h2><p>1.继承的概念：父亲儿子</p><p>2.继承的关键字：extends</p><p>3.继承的好处：</p><p>   （1）提高了代码的重用性</p><p>   （2）提高了代码的可扩展性</p><p>3.继承的语法：</p><pre><code>     public class 类名  extends 父类{    代码块   }</code></pre><p>4.继承的使用与说明：</p><p>   （1）使用：</p><p>可以直接调用父类的非私有属性和方法</p><p>​         可以用super.方法     super.属性</p><p>   （2）说明： Java中的继承只能单继承，</p><p>5.父类构造方法调用：super();</p><p>​     //super指代的是父类对象，this指代的是本类对象</p><p>​      调用父类的构造方法必须在之类中调用</p><p>​      必须实在之类构造方法的第一行代码</p><p>6.继承中的构造方法要点：</p><p>   （1）执行子类的构造方法，会默认执行父类的无参构造方法</p><p>  （2）当子类没有无参构造方法，但是有有参构造方法,子类的构造方法需手动添加</p><p>  （3）父类没有定义无参构造方法，定义了带参构造方法，子类的构造方法必须调用父类的带参构造方法。</p><p>  （4）无论是super还是this调用构造方法，只能放在第一行，构造方法只能调用一个</p><p>  （5）构造方法只能在构造方法中调用</p><p>7.重写@Override</p><p>​      必须继承</p><p>​      方法名一致，参数个数，顺序，类型全部一致</p><p>8.重载与重写的区别：</p><p>重载:一定发生在同一类中，方法名相同，参数不同（类型不同，数量不同）</p><p>重写：一定发生在父类和子类中，方法名相同，参数相同，方法体不同</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="第五章-面向对象—多态"><a href="#第五章-面向对象—多态" class="headerlink" title="第五章 面向对象—多态"></a>第五章 面向对象—多态</h2><p>1.多态的概念：不同对象对同一消息产生不同的响应。</p><p>2.多态的必要条件</p><p>   （1）继承</p><p>   （2）重写</p><p>   （3）父类引用指向子类对象（向上转型）</p><p>3.多态的优点：</p><p>   （1）消除类型之间的耦合关系</p><p>   （2）可替换性</p><p>   （3）可扩展性</p><p>   （4）接口性</p><p>   （5）灵活性</p><p>   （6）简化性</p><p>3.多态的使用</p><p>   （1）第一个例子</p><pre><code class="java"> public class Father{​         public void cooking(){​            System.out.println(&quot;米饭&quot;);​         }​      }​      public class Son extends Father{​         @Override​         public void cooking(){​            System.out.println(&quot;熬粥&quot;);​         }​      }​      public class Test {​         public static void main(String[] args) {​            Father son=new Son();​            son.cooking();​         }​      }</code></pre><p>   （2）第二个例子</p><pre><code class="java"> public class Test {​    public static void main(String[] args) {​      show(new Cat());  // 以 Cat 对象调用 show 方法​      show(new Dog());  // 以 Dog 对象调用 show 方法​                ​      Animal a = new Cat();  // 向上转型  ​      a.eat();               // 调用的是 Cat 的 eat​      Cat c = (Cat)a;        // 向下转型  ​      c.work();        // 调用的是 Cat 的 work  }  ​            ​    public static void show(Animal a)  {​      a.eat();  ​        // 类型判断​        if (a instanceof Cat)  {  // 猫做的事情 ​            Cat c = (Cat)a;  ​            c.work();  ​        } else if (a instanceof Dog) { // 狗做的事情 ​            Dog c = (Dog)a;  ​            c.work();  ​        }  ​    }  }abstract class Animal {  ​    abstract void eat();  }  class Cat extends Animal {  ​    public void eat() {  ​        System.out.println(&quot;吃鱼&quot;);  ​    }  ​    public void work() {  ​        System.out.println(&quot;抓老鼠&quot;);  ​    }  }  class Dog extends Animal {  ​    public void eat() {  ​        System.out.println(&quot;吃骨头&quot;);  ​    }  ​    public void work() {  ​        System.out.println(&quot;看家&quot;);  ​    }  }</code></pre><p> 4.向上转型（子类向父类的转换）  </p><pre><code> 语法 ：​      &lt;父类型&gt;  &lt;引用变量名&gt; = new  &lt;子类型&gt;（）；​      例如：Animal an1=new Dog（）；</code></pre><p>5.向下转型（必须基于向上转型）</p><pre><code>    例如：Son son=(Son)father;</code></pre><p>6.注意：</p><p>   （1）属性无多态这个属性，只看“=”左边的类型</p><p>   （2）编译时，能“.”出来，能调用的看“=”左边</p><p>7.Instanceof运算符：</p><p>8.异常的处理（Try-catch-finally块）：</p><pre><code>语法：​      Try{​         代码块；}catch（Exception  e）{   代码块；}finally{   代码块；}</code></pre><p>注意：</p><p>（1） catch（Exception  e）一定放在所有catch块的最后</p><p>（2） finally{}块里面的代码一定会执行</p><p>结束的语句：</p><pre><code>   （1）return；   （2）system.exit（0）;</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h2 id="第六章-抽象"><a href="#第六章-抽象" class="headerlink" title="第六章 抽象"></a>第六章 抽象</h2><p>1.抽象的概念:当一个类没有足够的信息去描述一个具体的对象，那么我们称之为抽象类。</p><p>2.抽象的关键字</p><p>​      abstract</p><p>​      可以修饰类，可以修饰方法</p><p>3.抽象类的作用：</p><p>   （1）抽象类是用来继承的</p><p>   （2）抽象类无法new出对象</p><p>4.抽象的用法</p><pre><code>     //抽象类​      public abstract class 类名{​         //抽象方法没有方法体​         public abstract void 方法名();   ​      }     //当父类是抽象类的时候，子类必须重写父类里面的抽象方法</code></pre><p>​     </p><p>5.final修饰符：最终的</p><p>   修饰变量，修饰方法，修饰类</p><p>   （1）.当修饰变量时，变量转换成常量，常量的值不能改变</p><p>​      final int a=18;//a=18;不能改变,必须给一个初始值</p><p>   （2）.当修饰方法时，该方法不能被重写</p><p>   （3）.当修饰类时，该类不能被继承</p><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><p>为什么要用接口？：因为JAVA只支持单继承。</p><ol><li>接口的概念</li></ol><p>2.接口的关键字</p><p>​      interface</p><p>3.接口的语法</p><pre><code>      public interface 接口名{}​      File---&gt;new---&gt;interface//创建接口</code></pre><p>4.接口的用法</p><pre><code>      实现接口的关键字  implements​      public interface 接口名{​         //接口是纯抽象类​         //接口里面的方法都是抽象方法​         void setData();​      }​      public class Play implements 接口名{​         @Override​         void setData(){​         }​      }​      public class Test {​         public static void main(String[] args) {​            Play play=new Play();​            play.setData();​         }​      }​      注意接口可以进行多继承​      public interface 接口名 extends 接口名，接口名{}​      一般用法​      public class 类名 extends 父类 implements 接口，接口{}</code></pre><p>多态与接口的区别：</p><p>（1） 多态：难</p><p>（2） 接口：简单，不能随意定义属性和方法，只能定义抽象方法，并且实现对口必须重写。</p><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h2 id="第八章-集合框架"><a href="#第八章-集合框架" class="headerlink" title="第八章 集合框架"></a>第八章 集合框架</h2><p>1.ArrayList</p><p>  1.用法</p><pre><code>     ArrayList list=new ArrayList();    list.add();//添加数据    list.get();//获取数据</code></pre><p>2.Map的用法：</p><pre><code>       Map map=new HasMap();​      map.put(key,value);//key不能重复​      map.get(key);//获取key对象的value</code></pre><p>3.泛型</p><pre><code>      ArrayList&lt;String&gt; list=new ArrayList&gt;&lt;String&gt;();      Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();      ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="undefined2019/10/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/10/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h3><pre><code class="java">System.out.println(&quot;小可爱，你好呀&quot;);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>